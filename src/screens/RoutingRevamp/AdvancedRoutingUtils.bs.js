// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";

function getCurrentDetailedUTCTime(param) {
  return new Date(Date.now()).toUTCString();
}

function getCurrentShortUTCTime(param) {
  var currentDate = new Date(Date.now());
  var currMonth = currentDate.getUTCMonth().toString();
  var currDay = currentDate.getUTCDate().toString();
  var currYear = currentDate.getUTCFullYear().toString();
  return "" + currYear + "-" + currMonth + "-" + currDay + "";
}

function operatorMapper(value) {
  switch (value) {
    case "CONTAINS":
      return /* CONTAINS */ 5;
    case "EQUAL TO":
      return /* EQUAL_TO */ 4;
    case "GREATER THAN":
      return /* GREATER_THAN */ 2;
    case "IS":
      return /* IS */ 0;
    case "IS_NOT":
      return /* IS_NOT */ 1;
    case "LESS THAN":
      return /* LESS_THAN */ 3;
    case "NOT EQUAL_TO":
      return /* NOT_EQUAL_TO */ 7;
    case "NOT_CONTAINS":
      return /* NOT_CONTAINS */ 6;
    default:
      return /* UnknownOperator */ {
        _0: "",
      };
  }
}

function getRoutingTypeName(routingType) {
  switch (routingType) {
    case /* PRIORITY */ 0:
      return "rank";
    case /* VOLUME_SPLIT */ 1:
      return "volume";
    case /* ADVANCED */ 2:
      return "rule";
    case /* DEFAULTFALLBACK */ 3:
      return "default";
    case /* NO_ROUTING */ 4:
      return "";
  }
}

function getRoutingNameString(routingType) {
  var routingText = getRoutingTypeName(routingType);
  return (
    "" +
    LogicUtils.capitalizeString(routingText) +
    " Based Routing-" +
    getCurrentShortUTCTime(undefined) +
    ""
  );
}

function getRoutingDescriptionString(routingType) {
  var routingText = getRoutingTypeName(routingType);
  return (
    "This is a " +
    routingText +
    " based routing created at " +
    new Date(Date.now()).toUTCString() +
    ""
  );
}

function getWasmKeyType(wasm, value) {
  try {
    if (wasm !== undefined) {
      return Curry._1(wasm.getKeyType, value);
    } else {
      return "";
    }
  } catch (exn) {
    return "";
  }
}

function getWasmVariantValues(wasm, value) {
  try {
    if (wasm !== undefined) {
      return Curry._1(wasm.getVariantValues, value);
    } else {
      return [];
    }
  } catch (exn) {
    return [];
  }
}

function getWasmPayoutVariantValues(wasm, value) {
  try {
    if (wasm !== undefined) {
      return Curry._1(wasm.getPayoutVariantValues, value);
    } else {
      return [];
    }
  } catch (exn) {
    return [];
  }
}

function variantTypeMapper(variantType) {
  switch (variantType) {
    case "enum_variant":
      return /* Enum_variant */ 1;
    case "metadata_value":
      return /* Metadata_value */ 2;
    case "number":
      return /* Number */ 0;
    case "str_value":
      return /* String_value */ 3;
    default:
      return /* UnknownVariant */ {
        _0: "",
      };
  }
}

function getStatementValue(valueDict) {
  return {
    type: LogicUtils.getString(valueDict, "type", ""),
    value: LogicUtils.getJsonObjectFromDict(valueDict, "value"),
  };
}

function statementTypeMapper(dict) {
  return {
    lhs: LogicUtils.getString(dict, "lhs", ""),
    comparison: LogicUtils.getString(dict, "comparison", ""),
    value: getStatementValue(LogicUtils.getDictfromDict(dict, "value")),
    logical: LogicUtils.getString(dict, "logical", ""),
  };
}

function conditionTypeMapper(statementArr) {
  return Core__Array.reduce(statementArr, [], function (acc, statementJson) {
    var conditionArray = LogicUtils.getArrayFromDict(
      LogicUtils.getDictFromJsonObject(statementJson),
      "condition",
      [],
    );
    var arr = conditionArray.map(function (conditionJson, index) {
      var statementDict = LogicUtils.getDictFromJsonObject(conditionJson);
      return {
        lhs: LogicUtils.getString(statementDict, "lhs", ""),
        comparison: LogicUtils.getString(statementDict, "comparison", ""),
        value: getStatementValue(
          LogicUtils.getDictfromDict(statementDict, "value"),
        ),
        logical: index === 0 ? "OR" : "AND",
      };
    });
    return acc.concat(arr);
  });
}

function volumeSplitConnectorSelectionDataMapper(dict) {
  return {
    split: LogicUtils.getInt(dict, "split", 0),
    connector: {
      connector: LogicUtils.getString(
        LogicUtils.getDictfromDict(dict, "connector"),
        "connector",
        "",
      ),
      merchant_connector_id: LogicUtils.getString(
        LogicUtils.getDictfromDict(dict, "connector"),
        "merchant_connector_id",
        "",
      ),
    },
  };
}

function priorityConnectorSelectionDataMapper(dict) {
  return {
    connector: LogicUtils.getString(dict, "connector", ""),
    merchant_connector_id: LogicUtils.getString(
      dict,
      "merchant_connector_id",
      "",
    ),
  };
}

function connectorSelectionDataMapperFromJson(json) {
  var split = LogicUtils.getOptionInt(
    LogicUtils.getDictFromJsonObject(json),
    "split",
  );
  var dict = LogicUtils.getDictFromJsonObject(json);
  if (split !== undefined) {
    return {
      TAG: /* VolumeObject */ 0,
      _0: volumeSplitConnectorSelectionDataMapper(dict),
    };
  } else {
    return {
      TAG: /* PriorityObject */ 1,
      _0: priorityConnectorSelectionDataMapper(dict),
    };
  }
}

function getDefaultSelection(defaultSelection) {
  var override3dsValue = LogicUtils.getString(
    defaultSelection,
    "override_3ds",
    "",
  );
  var surchargeDetailsOptionalValue = defaultSelection["surcharge_details"];
  var surchargeDetailsValue = LogicUtils.getDictfromDict(
    defaultSelection,
    "surcharge_details",
  );
  if (LogicUtils.isNonEmptyString(override3dsValue)) {
    return {
      override_3ds: override3dsValue,
    };
  }
  if (!Core__Option.isSome(surchargeDetailsOptionalValue)) {
    return {
      type: LogicUtils.getString(defaultSelection, "type", ""),
      data: LogicUtils.getArrayFromDict(defaultSelection, "data", []).map(
        connectorSelectionDataMapperFromJson,
      ),
    };
  }
  var surchargeValue = LogicUtils.getDictfromDict(
    surchargeDetailsValue,
    "surcharge",
  );
  return {
    surcharge_details: {
      surcharge: {
        type: LogicUtils.getString(surchargeValue, "type", ""),
        value: {
          percentage: LogicUtils.getFloat(
            LogicUtils.getDictfromDict(surchargeValue, "value"),
            "percentage",
            0.0,
          ),
          amount: LogicUtils.getFloat(
            LogicUtils.getDictfromDict(surchargeValue, "value"),
            "amount",
            0.0,
          ),
        },
      },
      tax_on_surcharge: {
        percentage: LogicUtils.getFloat(
          LogicUtils.getDictfromDict(surchargeDetailsValue, "tax_on_surcharge"),
          "percentage",
          0.0,
        ),
      },
    },
  };
}

function getConnectorStringFromConnectorSelectionData(connectorSelectionData) {
  if (connectorSelectionData.TAG === /* VolumeObject */ 0) {
    var obj = connectorSelectionData._0;
    return {
      connector: obj.connector.connector,
      merchant_connector_id: obj.connector.merchant_connector_id,
    };
  }
  var obj$1 = connectorSelectionData._0;
  return {
    connector: obj$1.connector,
    merchant_connector_id: obj$1.merchant_connector_id,
  };
}

function getSplitFromConnectorSelectionData(connectorSelectionData) {
  if (connectorSelectionData.TAG === /* VolumeObject */ 0) {
    return connectorSelectionData._0.split;
  } else {
    return 0;
  }
}

function ruleInfoTypeMapper(json) {
  var rulesArray = LogicUtils.getArrayFromDict(json, "rules", []);
  var defaultSelection = LogicUtils.getDictfromDict(json, "defaultSelection");
  var rulesModifiedArray = rulesArray.map(function (rule) {
    var ruleDict = LogicUtils.getDictFromJsonObject(rule);
    var connectorsDict = LogicUtils.getDictfromDict(
      ruleDict,
      "connectorSelection",
    );
    var connectorSelection = getDefaultSelection(connectorsDict);
    var ruleName = LogicUtils.getString(ruleDict, "name", "");
    return {
      name: ruleName,
      connectorSelection: connectorSelection,
      statements: conditionTypeMapper(
        LogicUtils.getArrayFromDict(ruleDict, "statements", []),
      ),
    };
  });
  return {
    defaultSelection: getDefaultSelection(defaultSelection),
    rules: rulesModifiedArray,
    metadata: LogicUtils.getJsonObjectFromDict(json, "metadata"),
  };
}

function getOperatorFromComparisonType(comparison, variantType) {
  switch (comparison) {
    case "equal":
      switch (variantType) {
        case "enum_variant":
          return "IS";
        case "enum_variant_array":
          return "CONTAINS";
        case "str_value":
          return "EQUAL_TO";
        default:
          return "IS";
      }
    case "greater_than":
      return "GREATER_THAN";
    case "less_than":
      return "LESS_THAN";
    case "not_equal":
      switch (variantType) {
        case "enum_variant":
          return "IS_NOT";
        case "enum_variant_array":
          return "NOT_CONTAINS";
        case "str_value":
          return "NOT EQUAL_TO";
        default:
          return "IS_NOT";
      }
    default:
      return "";
  }
}

function isStatementMandatoryFieldsPresent(statement) {
  var ele = Core__JSON.Classify.classify(statement.value.value);
  var statementValue;
  if (typeof ele === "number") {
    statementValue = false;
  } else {
    switch (ele.TAG | 0) {
      case /* String */ 1:
        statementValue = LogicUtils.isNonEmptyString(ele._0);
        break;
      case /* Array */ 4:
        statementValue = ele._0.length > 0;
        break;
      default:
        statementValue = false;
    }
  }
  if (
    LogicUtils.isNonEmptyString(statement.lhs) &&
    LogicUtils.isNonEmptyString(statement.value.type)
  ) {
    return statementValue;
  } else {
    return false;
  }
}

function algorithmTypeMapper(values) {
  return {
    data: ruleInfoTypeMapper(LogicUtils.getDictfromDict(values, "data")),
    type: LogicUtils.getString(values, "type", ""),
  };
}

function getRoutingTypesFromJson(values) {
  var valuesDict = LogicUtils.getDictFromJsonObject(values);
  return {
    name: LogicUtils.getString(valuesDict, "name", ""),
    description: LogicUtils.getString(valuesDict, "description", ""),
    algorithm: algorithmTypeMapper(
      LogicUtils.getDictfromDict(valuesDict, "algorithm"),
    ),
  };
}

function validateStatements(statementsArray) {
  return statementsArray.every(isStatementMandatoryFieldsPresent);
}

function generateStatements(statements) {
  var initialValueForStatement = {
    condition: [],
  };
  return Core__Array.reduce(
    statements,
    [initialValueForStatement],
    function (acc, statement) {
      var statementDict = LogicUtils.getDictFromJsonObject(statement);
      var logicalOperator = LogicUtils.getString(
        statementDict,
        "logical",
        "",
      ).toLowerCase();
      var lastItem = Core__Option.getOr(acc[(acc.length - 1) | 0], {
        condition: [],
      });
      var str = operatorMapper(
        LogicUtils.getString(statementDict, "comparison", ""),
      );
      var tmp;
      if (typeof str === "number") {
        switch (str) {
          case /* GREATER_THAN */ 2:
            tmp = "greater_than";
            break;
          case /* LESS_THAN */ 3:
            tmp = "less_than";
            break;
          case /* IS */ 0:
          case /* EQUAL_TO */ 4:
          case /* CONTAINS */ 5:
            tmp = "equal";
            break;
          case /* IS_NOT */ 1:
          case /* NOT_CONTAINS */ 6:
          case /* NOT_EQUAL_TO */ 7:
            tmp = "not_equal";
            break;
        }
      } else {
        tmp = str._0;
      }
      var condition_lhs = LogicUtils.getString(statementDict, "lhs", "");
      var condition_value = getStatementValue(
        LogicUtils.getDictfromDict(statementDict, "value"),
      );
      var condition_metadata = Caml_option.some(
        LogicUtils.getJsonObjectFromDict(statementDict, "metadata"),
      );
      var condition = {
        lhs: condition_lhs,
        comparison: tmp,
        value: condition_value,
        metadata: condition_metadata,
      };
      if (logicalOperator === "or") {
        return acc.concat([
          {
            condition: [condition],
          },
        ]);
      }
      lastItem.condition.push(condition);
      var filteredArr = acc.filter(function (param, i) {
        return i !== ((acc.length - 1) | 0);
      });
      filteredArr.push(lastItem);
      return filteredArr;
    },
  );
}

function generateRule(rulesDict) {
  return rulesDict.map(function (ruleJson) {
    var ruleDict = LogicUtils.getDictFromJsonObject(ruleJson);
    var statements = LogicUtils.getArrayFromDict(ruleDict, "statements", []);
    var modifiedStatements = generateStatements(statements);
    return {
      name: LogicUtils.getString(ruleDict, "name", ""),
      connectorSelection: LogicUtils.getJsonObjectFromDict(
        ruleDict,
        "connectorSelection",
      ),
      statements: modifiedStatements.map(function (prim) {
        return prim;
      }),
    };
  });
}

var defaultRule_connectorSelection = {
  type: "priority",
};

var defaultRule_statements = [
  {
    lhs: "",
    comparison: "",
    value: {
      type: "",
      value: "",
    },
  },
];

var defaultRule = {
  name: "rule_1",
  connectorSelection: defaultRule_connectorSelection,
  statements: defaultRule_statements,
};

var defaultAlgorithmData_defaultSelection = {
  type: "",
  data: [],
};

var defaultAlgorithmData_rules = [defaultRule];

var defaultAlgorithmData_metadata = {};

var defaultAlgorithmData = {
  defaultSelection: defaultAlgorithmData_defaultSelection,
  rules: defaultAlgorithmData_rules,
  metadata: defaultAlgorithmData_metadata,
};

var initialValues_name = getRoutingNameString(/* ADVANCED */ 2);

var initialValues_description = getRoutingDescriptionString(/* ADVANCED */ 2);

var initialValues_algorithm = {
  data: defaultAlgorithmData,
  type: "",
};

var initialValues = {
  name: initialValues_name,
  description: initialValues_description,
  algorithm: initialValues_algorithm,
};

function validateNameAndDescription(dict, errors) {
  ["name", "description"].forEach(function (field) {
    if (
      LogicUtils.isEmptyString(LogicUtils.getString(dict, field, "").trim())
    ) {
      errors[field] = "Please provide " + field + " field";
      return;
    }
  });
}

export {
  getCurrentDetailedUTCTime,
  getCurrentShortUTCTime,
  operatorMapper,
  getRoutingTypeName,
  getRoutingNameString,
  getRoutingDescriptionString,
  getWasmKeyType,
  getWasmVariantValues,
  getWasmPayoutVariantValues,
  variantTypeMapper,
  getStatementValue,
  statementTypeMapper,
  conditionTypeMapper,
  volumeSplitConnectorSelectionDataMapper,
  priorityConnectorSelectionDataMapper,
  connectorSelectionDataMapperFromJson,
  getDefaultSelection,
  getConnectorStringFromConnectorSelectionData,
  getSplitFromConnectorSelectionData,
  ruleInfoTypeMapper,
  getOperatorFromComparisonType,
  isStatementMandatoryFieldsPresent,
  algorithmTypeMapper,
  getRoutingTypesFromJson,
  validateStatements,
  generateStatements,
  generateRule,
  defaultRule,
  defaultAlgorithmData,
  initialValues,
  validateNameAndDescription,
};
/* initialValues Not a pure module */

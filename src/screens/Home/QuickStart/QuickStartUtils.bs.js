// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as LogicUtils from "../../../utils/LogicUtils.bs.js";
import * as ConnectorUtils from "../../Connectors/ConnectorUtils.bs.js";

function getTestConnectorName(connector, quickStartPageState) {
  switch (connector.TAG | 0) {
    case /* Processors */ 0:
      var match = connector._0;
      if (match === 6) {
        return "" + ConnectorUtils.getConnectorNameString(connector) + "_test";
      }
      if (match === 26) {
        return "" + ConnectorUtils.getConnectorNameString(connector) + "_test";
      }
      break;
    case /* ThreeDsAuthenticator */ 1:
    case /* UnknownConnector */ 2:
      break;
  }
  if (
    typeof quickStartPageState === "number" ||
    !(
      quickStartPageState.TAG === /* ConnectProcessor */ 0 &&
      quickStartPageState._0 === 0
    )
  ) {
    return "pretendpay";
  } else {
    return "fauxpay";
  }
}

var quickStartEnumIntialArray = [
  "ConfigurationType",
  "FirstProcessorConnected",
  "SecondProcessorConnected",
  "ConfiguredRouting",
  "TestPayment",
  "IntegrationMethod",
  "IntegrationCompleted",
  "DownloadWoocom",
  "ConfigureWoocom",
  "SetupWoocomWebhook",
  "StripeConnected",
  "PaypalConnected",
  "SPTestPayment",
  "OnboardingSurvey",
];

function connectorChoiceStringVariantMapper(stringValue) {
  switch (stringValue) {
    case "":
      return "NotSelected";
    case "Multiple":
      return "MultipleProcessorWithSmartRouting";
    case "Single":
      return "SinglePaymentProcessor";
    default:
      return "MultipleProcessorWithSmartRouting";
  }
}

function connectorChoiceVariantToString(variantValue) {
  if (variantValue === "SinglePaymentProcessor") {
    return "Single";
  } else if (variantValue === "MultipleProcessorWithSmartRouting") {
    return "Multiple";
  } else {
    return "";
  }
}

var connectorChoiceArray = [
  {
    displayText: "Single Payment Processor",
    description:
      "Connect any one processor and test a payment with Hyperswitch Checkout",
    variantType: "SinglePaymentProcessor",
  },
  {
    displayText: "Multiple processors with Smart Routing",
    description:
      "Connect a primary and secondary processor, define smart routing rules and test a payment with Hyperswitch Checkout",
    variantType: "MultipleProcessorWithSmartRouting",
  },
];

function getTypeOfConfigurationArray(selectedConnector) {
  var connectorName = ConnectorUtils.getDisplayNameForConnector(
    undefined,
    ConnectorUtils.getConnectorNameString(selectedConnector),
  );
  var testAPIDescription;
  switch (selectedConnector.TAG | 0) {
    case /* Processors */ 0:
      var match = selectedConnector._0;
      testAPIDescription =
        match !== 6
          ? match !== 26
            ? "We've got you covered. Try connecting with one of Hyperswitch's test processor to continue your setup."
            : "We've got you covered. Try connecting with our test processor modeled like " +
              connectorName +
              " to continue your setup."
          : "We've got you covered. Try connecting with our test processor modeled like " +
            connectorName +
            " to continue your setup.";
      break;
    case /* ThreeDsAuthenticator */ 1:
    case /* UnknownConnector */ 2:
      testAPIDescription =
        "We've got you covered. Try connecting with one of Hyperswitch's test processor to continue your setup.";
      break;
  }
  return [
    {
      displayText: "Try with a test processor",
      description: testAPIDescription,
      variantType: "TestApiKeys",
    },
    {
      displayText: "I have " + connectorName + " API keys",
      description:
        "Enter your " +
        connectorName +
        "  test mode secret key and enable desired payment methods to proceed with the setup. ",
      variantType: "ConnectorApiKeys",
    },
  ];
}

var getSmartRoutingConfigurationText = [
  {
    displayText: "Fallback routing (active - passive)",
    description:
      "Fallback to the secondary processor in case your primary processor couldn't process the transactions",
    variantType: "DefaultFallback",
    imageLink: "/assets/FallbackRoutingImage.svg",
  },
  {
    displayText: "Volume based routing (active - active)",
    description:
      "Split & route your transaction volume via more than one processor. Default is 50-50, this can be updated later",
    variantType: "VolumeBasedRouting",
    imageLink: "/assets/VolumeBasedRoutingImage.svg",
  },
];

var integrateYourAppArray = [
  {
    displayText: "Quick Integration for Stripe users",
    description:
      "Continue using Stripe with 40+ payment processors by changing few lines of code.",
    leftIcon: "stripe-icon",
    footerTags: ["Low code", "Stripe elements compatible"],
    variantType: "MigrateFromStripe",
  },
  {
    displayText: "Standard Integration",
    description: "Integrate Hyperswitch into your app with four simple steps",
    leftIcon: "hyperswitch-logo-short",
    footerTags: ["Code required", "Supports all platforms"],
    variantType: "StandardIntegration",
  },
];

function getProcessorType(value) {
  var processorID = LogicUtils.getString(value, "processor_id", "");
  var processorName = LogicUtils.getString(value, "processor_name", "");
  return {
    processorID: processorID,
    processorName: processorName,
  };
}

function getRoutingType(value) {
  return {
    routing_id: LogicUtils.getString(value, "routing_id", ""),
  };
}

function getPaymentType(value) {
  return {
    payment_id: LogicUtils.getString(value, "payment_id", ""),
  };
}

function getIntegrationType(value) {
  return {
    integration_type: LogicUtils.getString(value, "integration_type", ""),
  };
}

function getStringFromVariant(variant) {
  return variant;
}

function getTypedValueFromDict(valueString) {
  var value = LogicUtils.getDictFromJsonObject(valueString);
  return {
    productionAgreement: LogicUtils.getBool(
      value,
      "ProductionAgreement",
      false,
    ),
    firstProcessorConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "FirstProcessorConnected"),
    ),
    secondProcessorConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "SecondProcessorConnected"),
    ),
    configuredRouting: getRoutingType(
      LogicUtils.getDictfromDict(value, "ConfiguredRouting"),
    ),
    testPayment: getPaymentType(
      LogicUtils.getDictfromDict(value, "TestPayment"),
    ),
    integrationMethod: getIntegrationType(
      LogicUtils.getDictfromDict(value, "IntegrationMethod"),
    ),
    integrationCompleted: LogicUtils.getBool(
      value,
      "IntegrationCompleted",
      false,
    ),
    stripeConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "StripeConnected"),
    ),
    paypalConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "PaypalConnected"),
    ),
    sPRoutingConfigured: getRoutingType(
      LogicUtils.getDictfromDict(value, "SPRoutingConfigured"),
    ),
    sPTestPayment: LogicUtils.getBool(value, "SPTestPayment", false),
    downloadWoocom: LogicUtils.getBool(value, "DownloadWoocom", false),
    configureWoocom: LogicUtils.getBool(value, "ConfigureWoocom", false),
    setupWoocomWebhook: LogicUtils.getBool(value, "SetupWoocomWebhook", false),
    downloadTestAPIKeyStripe: LogicUtils.getString(
      value,
      "DownloadTestAPIKeyStripe",
      "",
    ),
    installDeps: LogicUtils.getString(value, "InstallDeps", ""),
    replaceAPIKeys: LogicUtils.getString(value, "ReplaceAPIKeys", ""),
    reconfigureCheckout: LogicUtils.getString(value, "ReconfigureCheckout", ""),
    loadCheckout: LogicUtils.getString(value, "LoadCheckout", ""),
    downloadTestAPIKey: LogicUtils.getString(value, "DownloadTestAPIKey", ""),
    createPayment: LogicUtils.getString(value, "CreatePayment", ""),
    displayCheckout: LogicUtils.getString(value, "DisplayCheckout", ""),
    displayPaymentConfirmation: LogicUtils.getString(
      value,
      "DisplayPaymentConfirmation",
      "",
    ),
    configurationType: LogicUtils.getString(value, "ConfigurationType", ""),
  };
}

function variantToEnumMapper(variantValue) {
  if (typeof variantValue === "number") {
    return "IntegrationCompleted";
  }
  switch (variantValue.TAG | 0) {
    case /* ConnectProcessor */ 0:
      switch (variantValue._0) {
        case /* CONFIGURE_PRIMARY */ 0:
          return "FirstProcessorConnected";
        case /* CONFIGURE_SECONDARY */ 1:
          return "SecondProcessorConnected";
        case /* CONFIGURE_SMART_ROUTING */ 2:
          return "ConfiguredRouting";
        case /* CHECKOUT */ 3:
        case /* LANDING */ 4:
          return "TestPayment";
      }
    case /* IntegrateApp */ 1:
      switch (variantValue._0) {
        case /* CHOOSE_INTEGRATION */ 1:
          return "IntegrationMethod";
        case /* LANDING */ 0:
        case /* CUSTOM_INTEGRATION */ 2:
          return "IntegrationCompleted";
      }
    case /* GoLive */ 2:
      return "IntegrationCompleted";
  }
}

function enumToVarinatMapper($$enum) {
  if ($$enum === "SecondProcessorConnected") {
    return {
      TAG: /* ConnectProcessor */ 0,
      _0: /* CONFIGURE_SECONDARY */ 1,
    };
  } else if ($$enum === "FirstProcessorConnected") {
    return {
      TAG: /* ConnectProcessor */ 0,
      _0: /* CONFIGURE_PRIMARY */ 0,
    };
  } else if ($$enum === "IntegrationMethod") {
    return {
      TAG: /* IntegrateApp */ 1,
      _0: /* CHOOSE_INTEGRATION */ 1,
    };
  } else if ($$enum === "TestPayment") {
    return {
      TAG: /* ConnectProcessor */ 0,
      _0: /* CHECKOUT */ 3,
    };
  } else if ($$enum === "IntegrationCompleted") {
    return {
      TAG: /* IntegrateApp */ 1,
      _0: /* CUSTOM_INTEGRATION */ 2,
    };
  } else if ($$enum === "ConfigurationType") {
    return {
      TAG: /* ConnectProcessor */ 0,
      _0: /* LANDING */ 4,
    };
  } else if ($$enum === "ConfiguredRouting") {
    return {
      TAG: /* ConnectProcessor */ 0,
      _0: /* CONFIGURE_SMART_ROUTING */ 2,
    };
  } else {
    return {
      TAG: /* GoLive */ 2,
      _0: /* LANDING */ 0,
    };
  }
}

function getStatusValue(comparator, enumVariant, dashboardPageState) {
  if (comparator.TAG === /* String */ 0) {
    if (LogicUtils.isNonEmptyString(comparator._0)) {
      return /* COMPLETED */ 0;
    } else if (dashboardPageState === enumVariant) {
      return /* ONGOING */ 1;
    } else {
      return /* PENDING */ 2;
    }
  } else if (comparator._0) {
    return /* COMPLETED */ 0;
  } else if (dashboardPageState === enumVariant) {
    return /* ONGOING */ 1;
  } else {
    return /* PENDING */ 2;
  }
}

function getStatusFromString(statusString) {
  var match = statusString.toUpperCase();
  switch (match) {
    case "COMPLETED":
      return /* COMPLETED */ 0;
    case "ONGOING":
      return /* ONGOING */ 1;
    case "PENDING":
      return /* PENDING */ 2;
    default:
      return /* PENDING */ 2;
  }
}

function sidebarTextBasedOnVariant(choiceState) {
  if (choiceState === "WooCommercePlugin") {
    return "Woocommerce plugin";
  } else if (choiceState === "StandardIntegration") {
    return "Standard integration";
  } else {
    return "Hyperswitch For Stripe Users";
  }
}

function getSidebarOptionsForIntegrateYourApp(
  enumDetails,
  quickStartPageState,
  currentRoute,
  choiceState,
) {
  var currentPageStateEnum = variantToEnumMapper(quickStartPageState);
  var enumValue = getTypedValueFromDict(LogicUtils.safeParse(enumDetails));
  var migrateFromStripeSidebar = [
    {
      title: "Choose integration method",
      status: getStatusValue(
        {
          TAG: /* String */ 0,
          _0: enumValue.integrationMethod.integration_type,
        },
        "IntegrationMethod",
        currentPageStateEnum,
      ),
      link: "/",
    },
    {
      title: sidebarTextBasedOnVariant(choiceState),
      status: getStatusValue(
        {
          TAG: /* Boolean */ 1,
          _0: enumValue.integrationCompleted,
        },
        "IntegrationCompleted",
        currentPageStateEnum,
      ),
      link: "/",
      subOptions: [
        {
          title: "Download Test API Keys",
          status: getStatusFromString(enumValue.downloadTestAPIKeyStripe),
        },
        {
          title: "Install Dependencies",
          status: getStatusFromString(enumValue.installDeps),
        },
        {
          title: "Replace API keys",
          status: getStatusFromString(enumValue.replaceAPIKeys),
        },
        {
          title: "Reconfigure Checkout Form",
          status: getStatusFromString(enumValue.reconfigureCheckout),
        },
        {
          title: "Load Hyperswitch Checkout",
          status: getStatusFromString(enumValue.loadCheckout),
        },
      ],
    },
  ];
  var standardIntegrationSidebar = [
    {
      title: "Choose integration method",
      status: getStatusValue(
        {
          TAG: /* String */ 0,
          _0: enumValue.integrationMethod.integration_type,
        },
        "IntegrationMethod",
        currentPageStateEnum,
      ),
      link: "/",
    },
    {
      title: sidebarTextBasedOnVariant(choiceState),
      status: getStatusValue(
        {
          TAG: /* Boolean */ 1,
          _0: enumValue.integrationCompleted,
        },
        "IntegrationCompleted",
        currentPageStateEnum,
      ),
      link: "/",
      subOptions: [
        {
          title: "Download Test API Key",
          status: getStatusFromString(enumValue.downloadTestAPIKey),
        },
        {
          title: "Create a Payment",
          status: getStatusFromString(enumValue.createPayment),
        },
        {
          title: "Display Hyperswitch Checkout",
          status: getStatusFromString(enumValue.displayCheckout),
        },
        {
          title: "Display Payment Confirmation",
          status: getStatusFromString(enumValue.displayPaymentConfirmation),
        },
      ],
    },
  ];
  if (currentRoute !== 1 && currentRoute === 0) {
    return migrateFromStripeSidebar;
  } else {
    return standardIntegrationSidebar;
  }
}

function getConnectorStatus(
  enumValueToCheck,
  connectorConfigureState,
  checkValue,
  currentEnum,
) {
  var isConnectorConnected = LogicUtils.isNonEmptyString(enumValueToCheck);
  if (isConnectorConnected || connectorConfigureState === checkValue) {
    return /* COMPLETED */ 0;
  } else if (Caml_obj.equal(connectorConfigureState, currentEnum)) {
    return /* ONGOING */ 1;
  } else {
    return /* PENDING */ 2;
  }
}

function getConnectorSubOptions(
  choiceStateForTestConnector,
  valueToCheck,
  connectorConfigureState,
) {
  if (choiceStateForTestConnector === "TestApiKeys") {
    return [];
  } else {
    return [
      {
        title: "Setup Sandbox Credentials",
        status: getConnectorStatus(
          valueToCheck.processorID,
          connectorConfigureState,
          /* Setup_payment_methods */ 3,
          /* Configure_keys */ 2,
        ),
      },
      {
        title: "Setup Payment Methods",
        status: getConnectorStatus(
          valueToCheck.processorID,
          connectorConfigureState,
          /* Summary */ 4,
          /* Setup_payment_methods */ 3,
        ),
      },
    ];
  }
}

function getSidebarOptionsForConnectProcessor(
  enumDetails,
  quickStartPageState,
  connectorConfigureState,
  choiceStateForTestConnector,
) {
  var enumValue = getTypedValueFromDict(LogicUtils.safeParse(enumDetails));
  var currentPageStateEnum = variantToEnumMapper(quickStartPageState);
  if (
    connectorChoiceStringVariantMapper(enumValue.configurationType) ===
    "MultipleProcessorWithSmartRouting"
  ) {
    return [
      {
        title: "Connect primary processor",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.firstProcessorConnected.processorID,
          },
          "FirstProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.firstProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Connect secondary processor",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.secondProcessorConnected.processorID,
          },
          "SecondProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.secondProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Configure smart routing",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.configuredRouting.routing_id,
          },
          "ConfiguredRouting",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
      {
        title: "Try hyperswitch checkout",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.testPayment.payment_id,
          },
          "TestPayment",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
    ];
  } else {
    return [
      {
        title: "Connect Primary Processor",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.firstProcessorConnected.processorID,
          },
          "FirstProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.firstProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Try hyperswitch checkout",
        status: getStatusValue(
          {
            TAG: /* String */ 0,
            _0: enumValue.testPayment.payment_id,
          },
          "TestPayment",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
    ];
  }
}

function textToVariantMapper(str) {
  switch (str) {
    case "MigrateFromStripe":
      return "MigrateFromStripe";
    case "StandardIntegration":
      return "StandardIntegration";
    case "WooCommercePlugin":
      return "WooCommercePlugin";
    default:
      return "MigrateFromStripe";
  }
}

function textToVariantMapperForBuildHS(str) {
  switch (str) {
    case "MigrateFromStripe":
      return /* MigrateFromStripe */ 0;
    case "StandardIntegration":
      return /* IntegrateFromScratch */ 1;
    case "WooCommercePlugin":
      return /* WooCommercePlugin */ 3;
    default:
      return /* MigrateFromStripe */ 0;
  }
}

function stringToVariantMapperForUserData(str) {
  switch (str) {
    case "ConfigurationType":
      return "ConfigurationType";
    case "ConfigureWoocom":
      return "ConfigureWoocom";
    case "ConfiguredRouting":
      return "ConfiguredRouting";
    case "DownloadWoocom":
      return "DownloadWoocom";
    case "FirstProcessorConnected":
      return "FirstProcessorConnected";
    case "IntegrationCompleted":
      return "IntegrationCompleted";
    case "IntegrationMethod":
      return "IntegrationMethod";
    case "PaypalConnected":
      return "PaypalConnected";
    case "ProductionAgreement":
      return "ProductionAgreement";
    case "SPRoutingConfigured":
      return "SPRoutingConfigured";
    case "SPTestPayment":
      return "SPTestPayment";
    case "SecondProcessorConnected":
      return "SecondProcessorConnected";
    case "SetupWoocomWebhook":
      return "SetupWoocomWebhook";
    case "StripeConnected":
      return "StripeConnected";
    case "TestPayment":
      return "TestPayment";
    default:
      return "ProductionAgreement";
  }
}

function generateBodyBasedOnType(parentVariant, value) {
  switch (value.TAG | 0) {
    case /* ProcesorType */ 0:
      var processorTypeVal = value._0;
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["processor_id", processorTypeVal.processorID],
            ["processor_name", processorTypeVal.processorName],
          ]),
        ],
      ]);
    case /* RoutingType */ 1:
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["routing_id", value._0.routing_id],
          ]),
        ],
      ]);
    case /* PaymentType */ 2:
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["payment_id", value._0.payment_id],
          ]),
        ],
      ]);
    case /* IntegrationMethod */ 3:
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["integration_type", value._0.integration_type],
          ]),
        ],
      ]);
    case /* Boolean */ 4:
      return parentVariant;
    case /* String */ 5:
      return value._0;
    case /* StringEnumType */ 6:
      return LogicUtils.getJsonFromArrayOfJson([[parentVariant, value._0]]);
  }
}

function getInitialValueForConnector(enumValue) {
  var arr = [];
  if (
    LogicUtils.isNonEmptyString(enumValue.firstProcessorConnected.processorID)
  ) {
    arr.push(enumValue.firstProcessorConnected.processorName);
  }
  if (
    LogicUtils.isNonEmptyString(enumValue.secondProcessorConnected.processorID)
  ) {
    arr.push(enumValue.secondProcessorConnected.processorName);
  }
  return arr;
}

function checkEmptyDict(dict, variant) {
  return LogicUtils.isEmptyDict(
    LogicUtils.getDictFromJsonObject(
      LogicUtils.getJsonObjectFromDict(dict, variant),
    ),
  );
}

function checkBool(dict, variant) {
  return LogicUtils.getBool(dict, variant, false);
}

function checkString(dict, variant) {
  return LogicUtils.getString(dict, variant, "");
}

function getCurrentStep(dict) {
  if (
    LogicUtils.getString(dict, "ConfigurationType", "").length === 0 &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "ConfigurationType";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "SinglePaymentProcessor" &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "FirstProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "SinglePaymentProcessor" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "TestPayment") === true
  ) {
    return "TestPayment";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "SinglePaymentProcessor" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "IntegrationMethod") === true
  ) {
    return "IntegrationMethod";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "MultipleProcessorWithSmartRouting" &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "FirstProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "SecondProcessorConnected")
  ) {
    return "SecondProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    checkEmptyDict(dict, "ConfiguredRouting")
  ) {
    return "ConfiguredRouting";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    !checkEmptyDict(dict, "ConfiguredRouting") &&
    checkEmptyDict(dict, "TestPayment")
  ) {
    return "TestPayment";
  } else if (
    connectorChoiceStringVariantMapper(
      LogicUtils.getString(dict, "ConfigurationType", ""),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    !checkEmptyDict(dict, "ConfiguredRouting") &&
    checkEmptyDict(dict, "IntegrationMethod")
  ) {
    return "IntegrationMethod";
  } else if (
    !checkEmptyDict(dict, "IntegrationMethod") &&
    !LogicUtils.getBool(dict, "IntegrationCompleted", false)
  ) {
    return "IntegrationCompleted";
  } else {
    return "GoLive";
  }
}

export {
  getTestConnectorName,
  quickStartEnumIntialArray,
  connectorChoiceStringVariantMapper,
  connectorChoiceVariantToString,
  connectorChoiceArray,
  getTypeOfConfigurationArray,
  getSmartRoutingConfigurationText,
  integrateYourAppArray,
  getProcessorType,
  getRoutingType,
  getPaymentType,
  getIntegrationType,
  getStringFromVariant,
  getTypedValueFromDict,
  variantToEnumMapper,
  enumToVarinatMapper,
  getStatusValue,
  getStatusFromString,
  sidebarTextBasedOnVariant,
  getSidebarOptionsForIntegrateYourApp,
  getConnectorStatus,
  getConnectorSubOptions,
  getSidebarOptionsForConnectProcessor,
  textToVariantMapper,
  textToVariantMapperForBuildHS,
  stringToVariantMapperForUserData,
  generateBodyBasedOnType,
  getInitialValueForConnector,
  checkEmptyDict,
  checkBool,
  checkString,
  getCurrentStep,
};
/* LogicUtils Not a pure module */

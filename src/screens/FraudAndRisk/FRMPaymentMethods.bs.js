// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Form from "../../genericUtils/Form.bs.js";
import * as Icon from "../../components/Icon.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as FRMInfo from "./FRMInfo.bs.js";
import * as ToolTip from "../../components/tooltip/ToolTip.bs.js";
import * as UIUtils from "../../utils/UIUtils.bs.js";
import * as FRMUtils from "./FRMUtils.bs.js";
import * as Accordion from "../componentsDemo/Accordion.bs.js";
import * as RadioIcon from "../../components/custom-icons/RadioIcon.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as PopUpState from "../../hooks/PopUpState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as FormRenderer from "../../components/form/FormRenderer.bs.js";
import * as FormValuesSpy from "../../components/form/FormValuesSpy.bs.js";
import * as ReactFinalForm from "react-final-form";
import * as React$1 from "@headlessui/react";
import * as ConnectorListHook from "../Hooks/ConnectorListHook.bs.js";
import * as PageLoaderWrapper from "../Utils/PageLoaderWrapper.bs.js";
import * as JsxPPXReactSupport from "rescript/lib/es6/jsxPPXReactSupport.js";

function FRMPaymentMethods$RadioSection(props) {
  var setConfigJson = props.setConfigJson;
  var sectionType = props.sectionType;
  var paymentMethodTypeInfo = props.paymentMethodTypeInfo;
  var frmConfigs = props.frmConfigs;
  var option = props.option;
  var isOptionSelected =
    (sectionType
      ? paymentMethodTypeInfo.action
      : paymentMethodTypeInfo.flow) === option;
  return React.createElement(
    "div",
    undefined,
    React.createElement(
      "div",
      {
        className: "flex items-center gap-2 break-all",
      },
      React.createElement(
        "div",
        {
          onClick: function (param) {
            if (sectionType) {
              paymentMethodTypeInfo.action = option;
            } else if (paymentMethodTypeInfo.flow !== option) {
              var match = FRMInfo.getFlowTypeVariantFromString(option);
              if (match) {
                paymentMethodTypeInfo.action = FRMInfo.getActionTypeNameString(
                  /* ManualReview */ 2,
                );
              } else {
                paymentMethodTypeInfo.action = FRMInfo.getActionTypeNameString(
                  /* CancelTxn */ 0,
                );
              }
              paymentMethodTypeInfo.flow = option;
            }
            Curry._1(setConfigJson, frmConfigs);
          },
        },
        React.createElement(RadioIcon.make, {
          isSelected: isOptionSelected,
        }),
      ),
      sectionType
        ? LogicUtils.snakeToTitle(FRMInfo.getActionTypeLabel(option))
        : FRMInfo.getFlowTypeLabel(option),
    ),
  );
}

var RadioSection = {
  make: FRMPaymentMethods$RadioSection,
};

function FRMPaymentMethods$ToggleSwitch(props) {
  var handleOnChange = props.handleOnChange;
  var isOpen = props.isOpen;
  var cursorType = props.isToggleDisabled
    ? "cursor-not-allowed"
    : "cursor-pointer";
  var enabledClasses = isOpen
    ? "bg-green-700 " + cursorType + " " + FRMUtils.toggleDefaultStyle + ""
    : "bg-gray-300 " + cursorType + " " + FRMUtils.toggleDefaultStyle + "";
  var enabledSpanClasses = isOpen
    ? "translate-x-7 " + FRMUtils.accordionDefaultStyle + ""
    : "translate-x-1 " + FRMUtils.accordionDefaultStyle + "";
  return React.createElement(React$1.Switch, {
    checked: isOpen,
    onChange: function (param) {
      Curry._1(handleOnChange, undefined);
    },
    className: enabledClasses,
    children: function (checked) {
      return React.createElement(
        React.Fragment,
        undefined,
        React.createElement("div", {
          "aria-hidden": true,
          className: enabledSpanClasses,
        }),
      );
    },
  });
}

var ToggleSwitch = {
  make: FRMPaymentMethods$ToggleSwitch,
};

function FRMPaymentMethods$FormField(props) {
  var setConfigJson = props.setConfigJson;
  var sectionType = props.sectionType;
  var frmConfigs = props.frmConfigs;
  var paymentMethodTypeInfo = props.paymentMethodTypeInfo;
  return React.createElement(
    "div",
    {
      className: "w-max",
    },
    React.createElement(
      "div",
      {
        className: "flex",
      },
      React.createElement(
        "h3",
        {
          className: "font-semibold text-bold text-lg pb-2",
        },
        LogicUtils.snakeToTitle(props.label),
      ),
      React.createElement(
        "div",
        {
          className: "w-10 h-7 text-gray-300",
        },
        React.createElement(ToolTip.make, {
          description: props.description,
          toolTipFor: Caml_option.some(
            React.createElement(Icon.make, {
              name: "info-circle",
              size: 15,
            }),
          ),
          tooltipWidthClass: "w-96",
          toolTipPosition: /* Top */ 0,
        }),
      ),
    ),
    React.createElement(
      "div",
      {
        className: "grid grid-cols-2 md:grid-cols-4 gap-4",
      },
      React.createElement(UIUtils.RenderIf.make, {
        condition: sectionType === /* ActionType */ 1,
        children: React.createElement(
          "div",
          {
            className: "flex items-center gap-2 break-all",
          },
          FRMInfo.getActionTypeLabel(paymentMethodTypeInfo.action),
        ),
      }),
      React.createElement(UIUtils.RenderIf.make, {
        condition: sectionType !== /* ActionType */ 1,
        children: props.options.map(function (option, i) {
          return JsxPPXReactSupport.createElementWithKey(
            i.toString(),
            FRMPaymentMethods$RadioSection,
            {
              option: option,
              frmConfigs: frmConfigs,
              paymentMethodTypeInfo: paymentMethodTypeInfo,
              sectionType: sectionType,
              setConfigJson: setConfigJson,
            },
          );
        }),
      }),
    ),
  );
}

var FormField = {
  make: FRMPaymentMethods$FormField,
};

function FRMPaymentMethods$CheckBoxRenderer(props) {
  var isUpdateFlow = props.isUpdateFlow;
  var connectorPaymentMethods = props.connectorPaymentMethods;
  var frmConfigs = props.frmConfigs;
  var frmConfigInfo = props.frmConfigInfo;
  var showPopUp = PopUpState.useShowPopUp(undefined);
  var frmConfigInput = ReactFinalForm.useField("frm_configs").input;
  var setConfigJson = frmConfigInput.onChange;
  var isToggleDisabled =
    connectorPaymentMethods !== undefined
      ? Object.keys(Caml_option.valFromOption(connectorPaymentMethods))
          .length <= 0
      : true;
  var initToggleValue = isUpdateFlow
    ? frmConfigInfo.payment_methods.length > 0
    : !isToggleDisabled;
  var match = React.useState(function () {
    return initToggleValue;
  });
  var setIsOpen = match[1];
  var isOpen = match[0];
  var handleOnChange = function (param) {
    if (!isToggleDisabled) {
      if (isOpen) {
        if (frmConfigInfo.payment_methods.length > 0) {
          if (isUpdateFlow) {
            return Curry._1(showPopUp, {
              heading: "Heads up!",
              description:
                "Disabling the current toggle will result in the permanent deletion of all configurations associated with it",
              popUpType: [/* Warning */ 4, /* WithIcon */ 0],
              handleCancel: {
                text: "No",
                onClick: function (param) {},
              },
              handleConfirm: {
                text: "Yes, disable it",
                onClick: function (param) {
                  frmConfigInfo.payment_methods = [];
                  Curry._1(setIsOpen, function (param) {
                    return !isOpen;
                  });
                  Curry._1(setConfigJson, frmConfigs);
                },
              },
            });
          } else {
            frmConfigInfo.payment_methods = [];
            Curry._1(setConfigJson, frmConfigs);
            return Curry._1(setIsOpen, function (param) {
              return !isOpen;
            });
          }
        } else {
          return;
        }
      } else {
        if (connectorPaymentMethods !== undefined) {
          frmConfigInfo.payment_methods =
            FRMUtils.generateFRMPaymentMethodsConfig(
              Caml_option.valFromOption(connectorPaymentMethods),
            );
          Curry._1(setConfigJson, frmConfigs);
        }
        return Curry._1(setIsOpen, function (param) {
          return !isOpen;
        });
      }
    }
  };
  React.useEffect(function () {
    if (isOpen && !isUpdateFlow && connectorPaymentMethods !== undefined) {
      frmConfigInfo.payment_methods = FRMUtils.generateFRMPaymentMethodsConfig(
        Caml_option.valFromOption(connectorPaymentMethods),
      );
      Curry._1(setConfigJson, frmConfigs);
    }
  }, []);
  return React.createElement(
    "div",
    undefined,
    React.createElement(
      "div",
      {
        className:
          "w-full px-5 py-3 bg-light-gray-bg flex items-center gap-3 justify-between border",
      },
      React.createElement(
        "div",
        {
          className: "font-semibold text-bold text-lg",
        },
        LogicUtils.snakeToTitle(frmConfigInfo.gateway),
      ),
      React.createElement(
        "div",
        {
          className: "mt-2",
        },
        isToggleDisabled
          ? React.createElement(ToolTip.make, {
              description: "No payment methods available",
              toolTipFor: Caml_option.some(
                React.createElement(FRMPaymentMethods$ToggleSwitch, {
                  isOpen: isOpen,
                  handleOnChange: handleOnChange,
                  isToggleDisabled: isToggleDisabled,
                }),
              ),
              toolTipPosition: /* Top */ 0,
            })
          : React.createElement(FRMPaymentMethods$ToggleSwitch, {
              isOpen: isOpen,
              handleOnChange: handleOnChange,
              isToggleDisabled: isToggleDisabled,
            }),
      ),
    ),
    frmConfigInfo.payment_methods.map(function (paymentMethodInfo, index) {
      return JsxPPXReactSupport.createElementWithKey(
        index.toString(),
        UIUtils.RenderIf.make,
        {
          condition: isOpen,
          children: paymentMethodInfo.payment_method_types.map(
            function (paymentMethodTypeInfo, i) {
              return JsxPPXReactSupport.createElementWithKey(
                i.toString(),
                Accordion.make,
                {
                  accordion: [
                    {
                      title: LogicUtils.snakeToTitle(
                        paymentMethodTypeInfo.payment_method_type,
                      ),
                      renderContent: function (param) {
                        return React.createElement(
                          "div",
                          {
                            className: "grid grid-cols-1 lg:grid-cols-2 gap-5",
                          },
                          React.createElement(FRMPaymentMethods$FormField, {
                            options: FRMInfo.flowTypeAllOptions,
                            label: "Choose one of the flows",
                            paymentMethodTypeInfo: paymentMethodTypeInfo,
                            frmConfigs: frmConfigs,
                            sectionType: /* FlowType */ 0,
                            setConfigJson: setConfigJson,
                            description:
                              'i. "PreAuth" - facilitate transaction verification prior to payment authorization.\n                        ii. "PostAuth" - facilitate transaction validation post-authorization, before amount capture.',
                          }),
                          React.createElement(FRMPaymentMethods$FormField, {
                            options: FRMInfo.getActionTypeAllOptions(
                              paymentMethodTypeInfo.flow,
                            ),
                            label: "Preferred Action",
                            paymentMethodTypeInfo: paymentMethodTypeInfo,
                            frmConfigs: frmConfigs,
                            sectionType: /* ActionType */ 1,
                            setConfigJson: setConfigJson,
                            description: FRMInfo.actionDescriptionForFlow(
                              FRMInfo.getFlowTypeVariantFromString(
                                paymentMethodTypeInfo.flow,
                              ),
                            ),
                          }),
                        );
                      },
                      renderContentOnTop: undefined,
                    },
                  ],
                  accordianTopContainerCss: "border",
                  accordianBottomContainerCss: "p-5",
                  contentExpandCss: "px-10 pb-6 pt-3 !border-t-0",
                  initialExpandedArray: [0],
                  titleStyle: "font-semibold text-bold text-md",
                },
              );
            },
          ),
        },
      );
    }),
  );
}

var CheckBoxRenderer = {
  make: FRMPaymentMethods$CheckBoxRenderer,
};

function FRMPaymentMethods$PaymentMethodsRenderer(props) {
  var isUpdateFlow = props.isUpdateFlow;
  var match = React.useState(function () {
    return /* Loading */ 0;
  });
  var setPageState = match[1];
  var frmConfigInput = ReactFinalForm.useField("frm_configs").input;
  var frmConfigs = FRMUtils.parseFRMConfig(frmConfigInput.value);
  var match$1 = React.useState(function () {
    return {};
  });
  var setConnectorConfig = match$1[1];
  var connectorConfig = match$1[0];
  var setConfigJson = frmConfigInput.onChange;
  var fetchConnectorListResponse =
    ConnectorListHook.useFetchConnectorList(undefined);
  var getConfiguredConnectorDetails = async function (param) {
    try {
      var response = await Curry._1(fetchConnectorListResponse, undefined);
      var connectorsConfig = FRMUtils.getConnectorConfig(
        FRMUtils.filterList(
          FRMUtils.filterList(
            LogicUtils.getArrayFromJson(response, []).map(
              LogicUtils.getDictFromJsonObject,
            ),
            /* FRMPlayer */ 1,
            undefined,
          ),
          /* ThreedsAuthenticator */ 2,
          undefined,
        ),
      );
      var updateFRMConfig = FRMUtils.createAllOptions(connectorsConfig).map(
        function (defaultConfig) {
          var config = frmConfigs.find(function (item) {
            return item.gateway === defaultConfig.gateway;
          });
          if (config !== undefined) {
            return config;
          } else {
            return defaultConfig;
          }
        },
      );
      Curry._1(setConnectorConfig, function (param) {
        return connectorsConfig;
      });
      Curry._1(setConfigJson, updateFRMConfig);
      return Curry._1(setPageState, function (param) {
        return /* Success */ 1;
      });
    } catch (exn) {
      return Curry._1(setPageState, function (param) {
        return /* Error */ {
          _0: "Failed to fetch",
        };
      });
    }
  };
  React.useEffect(function () {
    getConfiguredConnectorDetails(undefined);
  }, []);
  return React.createElement(PageLoaderWrapper.make, {
    children: Caml_option.some(
      React.createElement(
        "div",
        {
          className: "flex flex-col gap-4",
        },
        frmConfigs.map(function (configInfo, i) {
          return JsxPPXReactSupport.createElementWithKey(
            i.toString(),
            FRMPaymentMethods$CheckBoxRenderer,
            {
              frmConfigInfo: configInfo,
              frmConfigs: frmConfigs,
              connectorPaymentMethods: connectorConfig[configInfo.gateway],
              isUpdateFlow: isUpdateFlow,
            },
          );
        }),
      ),
    ),
    screenState: match[0],
  });
}

var PaymentMethodsRenderer = {
  make: FRMPaymentMethods$PaymentMethodsRenderer,
};

function FRMPaymentMethods(props) {
  var setInitialValues = props.setInitialValues;
  var retrivedValues = props.retrivedValues;
  var setCurrentStep = props.setCurrentStep;
  var retrivedValues$1 =
    retrivedValues !== undefined
      ? Caml_option.valFromOption(retrivedValues)
      : undefined;
  var initialValues = Core__Option.getOr(retrivedValues$1, {});
  var onSubmit = function (values, param) {
    var valuesDict = LogicUtils.getDictFromJsonObject(values);
    var filteredArray = FRMUtils.parseFRMConfig(
      LogicUtils.getJsonObjectFromDict(valuesDict, "frm_configs"),
    ).filter(function (config) {
      return config.payment_methods.length > 0;
    });
    valuesDict["frm_configs"] = filteredArray;
    Curry._1(setInitialValues, function (param) {
      return valuesDict;
    });
    Curry._1(setCurrentStep, FRMInfo.getNextStep);
    return Promise.resolve(null);
  };
  var validate = function (_values) {
    return {};
  };
  return React.createElement(
    Form.make,
    {
      children: null,
      onSubmit: onSubmit,
      initialValues: Caml_option.some(initialValues),
      validate: validate,
    },
    React.createElement(
      "div",
      {
        className: "flex",
      },
      React.createElement(
        "div",
        {
          className: "flex flex-col w-full",
        },
        React.createElement(
          "div",
          {
            className: "w-full flex justify-end mb-5",
          },
          React.createElement(FormRenderer.SubmitButton.make, {
            text: "Proceed",
          }),
        ),
        React.createElement(
          "div",
          {
            className: "flex flex-col gap-2 col-span-3",
          },
          React.createElement(FRMPaymentMethods$PaymentMethodsRenderer, {
            isUpdateFlow: props.isUpdateFlow,
          }),
        ),
      ),
    ),
    React.createElement(FormValuesSpy.make, {}),
  );
}

var make = FRMPaymentMethods;

export {
  RadioSection,
  ToggleSwitch,
  FormField,
  CheckBoxRenderer,
  PaymentMethodsRenderer,
  make,
};
/* Form Not a pure module */

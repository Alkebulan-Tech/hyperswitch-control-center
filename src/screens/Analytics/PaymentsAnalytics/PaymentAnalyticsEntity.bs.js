// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Table from "../../../components/Table.bs.js";
import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as EntityType from "../../../entities/EntityType.bs.js";
import * as LogicUtils from "../../../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as DynamicChart from "../../../components/DynamicChart.bs.js";
import * as ErrorReasons from "../ErrorReasons.bs.js";
import * as FormRenderer from "../../../components/form/FormRenderer.bs.js";
import * as DateTimeUtils from "../../../utils/DateTimeUtils.bs.js";
import * as AnalyticsTypes from "../AnalyticsTypes.bs.js";
import * as AnalyticsUtils from "../../../entities/analytics/AnalyticsUtils.bs.js";
import * as HSAnalyticsUtils from "../HSAnalyticsUtils.bs.js";

var domain = "payments";

function colMapper(col) {
  switch (col) {
    case /* SuccessRate */ 0:
      return "payment_success_rate";
    case /* Count */ 1:
      return "payment_count";
    case /* SuccessCount */ 2:
      return "payment_success_count";
    case /* ProcessedAmount */ 3:
      return "payment_processed_amount";
    case /* AvgTicketSize */ 4:
      return "avg_ticket_size";
    case /* Connector */ 5:
      return "connector";
    case /* PaymentErrorMessage */ 6:
      return "payment_error_message";
    case /* PaymentMethod */ 7:
      return "payment_method";
    case /* PaymentMethodType */ 8:
      return "payment_method_type";
    case /* Currency */ 9:
      return "currency";
    case /* AuthType */ 10:
      return "authentication_type";
    case /* Status */ 11:
      return "status";
    case /* WeeklySuccessRate */ 12:
      return "weekly_payment_success_rate";
    case /* NoCol */ 13:
      return "";
  }
}

function reverseColMapper(column) {
  switch (column) {
    case "authentication_type":
      return /* AuthType */ 10;
    case "avg_ticket_size":
      return /* AvgTicketSize */ 4;
    case "connector":
      return /* Connector */ 5;
    case "currency":
      return /* Currency */ 9;
    case "payment_count":
      return /* Count */ 1;
    case "payment_method":
      return /* PaymentMethod */ 7;
    case "payment_method_type":
      return /* PaymentMethodType */ 8;
    case "payment_processed_amount":
      return /* ProcessedAmount */ 3;
    case "payment_success_count":
      return /* SuccessCount */ 2;
    case "payment_success_rate":
      return /* SuccessRate */ 0;
    case "status":
      return /* Status */ 11;
    case "weekly_payment_success_rate":
      return /* WeeklySuccessRate */ 12;
    default:
      return /* NoCol */ 13;
  }
}

var weeklyTableMetricsCols = [
  {
    refKey: "payment_success_rate",
    newKey: "weekly_payment_success_rate",
  },
];

function percentFormat(value) {
  return "" + value.toFixed(2) + "%";
}

function getWeeklySR(dict) {
  var val = LogicUtils.getOptionFloat(dict, "weekly_payment_success_rate");
  if (val !== undefined) {
    return percentFormat(val);
  } else {
    return "NA";
  }
}

var distribution = Object.fromEntries([
  ["distributionFor", "payment_error_message"],
  ["distributionCardinality", "TOP_5"],
]);

function tableItemToObjMapper(dict) {
  var parseErrorReasons = function (dict) {
    return LogicUtils.getArrayFromDict(dict, "payment_error_message", []).map(
      function (errorJson) {
        var dict = LogicUtils.getDictFromJsonObject(errorJson);
        return {
          reason: LogicUtils.getString(dict, "reason", ""),
          count: LogicUtils.getInt(dict, "count", 0),
          percentage: LogicUtils.getFloat(dict, "percentage", 0.0),
        };
      },
    );
  };
  return {
    payment_success_rate: LogicUtils.getFloat(
      dict,
      "payment_success_rate",
      0.0,
    ),
    payment_count: LogicUtils.getFloat(dict, "payment_count", 0.0),
    payment_success_count: LogicUtils.getFloat(
      dict,
      "payment_success_count",
      0.0,
    ),
    payment_processed_amount: LogicUtils.getFloat(
      dict,
      "payment_processed_amount",
      0.0,
    ),
    payment_error_message: parseErrorReasons(dict),
    avg_ticket_size: LogicUtils.getFloat(dict, "avg_ticket_size", 0.0),
    connector: LogicUtils.getFirstLetterCaps(
      LogicUtils.getString(dict, "connector", "OTHER"),
      undefined,
      undefined,
    ),
    payment_method: LogicUtils.getFirstLetterCaps(
      LogicUtils.getString(dict, "payment_method", "OTHER"),
      undefined,
      undefined,
    ),
    payment_method_type: LogicUtils.getFirstLetterCaps(
      LogicUtils.getString(dict, "payment_method_type", "OTHER"),
      undefined,
      undefined,
    ),
    currency: LogicUtils.getString(dict, "currency", "OTHER").toUpperCase(),
    authentication_type: LogicUtils.getString(
      dict,
      "authentication_type",
      "OTHER",
    ).toUpperCase(),
    refund_status: LogicUtils.getString(dict, "status", "OTHER").toUpperCase(),
    weekly_payment_success_rate: getWeeklySR(dict).toUpperCase(),
  };
}

function getUpdatedHeading(param, param$1) {
  return function (colType) {
    var key = colMapper(colType);
    switch (colType) {
      case /* SuccessRate */ 0:
        return Table.makeHeaderInfo(
          key,
          "Success Rate",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* Count */ 1:
        return Table.makeHeaderInfo(
          key,
          "Payment Count",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* SuccessCount */ 2:
        return Table.makeHeaderInfo(
          key,
          "Payment Success Count",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* ProcessedAmount */ 3:
        return Table.makeHeaderInfo(
          key,
          "Payment Processed Amount",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* AvgTicketSize */ 4:
        return Table.makeHeaderInfo(
          key,
          "Avg Ticket Size",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* Connector */ 5:
        return Table.makeHeaderInfo(
          key,
          "Connector",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* PaymentErrorMessage */ 6:
        return Table.makeHeaderInfo(
          key,
          "Top 5 Error Reasons",
          /* TextType */ 1,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* PaymentMethod */ 7:
        return Table.makeHeaderInfo(
          key,
          "Payment Method",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* PaymentMethodType */ 8:
        return Table.makeHeaderInfo(
          key,
          "Payment Method Type",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* Currency */ 9:
        return Table.makeHeaderInfo(
          key,
          "Currency",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* AuthType */ 10:
        return Table.makeHeaderInfo(
          key,
          "Authentication Type",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* Status */ 11:
        return Table.makeHeaderInfo(
          key,
          "Status",
          /* DropDown */ 5,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* WeeklySuccessRate */ 12:
        return Table.makeHeaderInfo(
          key,
          "Current Week S.R",
          /* NumericType */ 3,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      case /* NoCol */ 13:
        return Table.makeHeaderInfo(
          key,
          "",
          undefined,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
    }
  };
}

function getCell(paymentTable, colType) {
  var usaNumberAbbreviation = function (labelValue) {
    return LogicUtils.shortNum(
      labelValue,
      LogicUtils.getDefaultNumberFormat(undefined),
      undefined,
      undefined,
    );
  };
  switch (colType) {
    case /* SuccessRate */ 0:
      return {
        TAG: /* Numeric */ 15,
        _0: paymentTable.payment_success_rate,
        _1: percentFormat,
      };
    case /* Count */ 1:
      return {
        TAG: /* Numeric */ 15,
        _0: paymentTable.payment_count,
        _1: usaNumberAbbreviation,
      };
    case /* SuccessCount */ 2:
      return {
        TAG: /* Numeric */ 15,
        _0: paymentTable.payment_success_count,
        _1: usaNumberAbbreviation,
      };
    case /* ProcessedAmount */ 3:
      return {
        TAG: /* Numeric */ 15,
        _0: paymentTable.payment_processed_amount / 100.0,
        _1: usaNumberAbbreviation,
      };
    case /* AvgTicketSize */ 4:
      return {
        TAG: /* Numeric */ 15,
        _0: paymentTable.avg_ticket_size / 100.0,
        _1: usaNumberAbbreviation,
      };
    case /* Connector */ 5:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.connector,
      };
    case /* PaymentErrorMessage */ 6:
      return {
        TAG: /* CustomCell */ 10,
        _0: React.createElement(ErrorReasons.make, {
          errors: paymentTable.payment_error_message,
        }),
        _1: "NA",
      };
    case /* PaymentMethod */ 7:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.payment_method,
      };
    case /* PaymentMethodType */ 8:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.payment_method_type,
      };
    case /* Currency */ 9:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.currency,
      };
    case /* AuthType */ 10:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.authentication_type,
      };
    case /* Status */ 11:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.refund_status,
      };
    case /* WeeklySuccessRate */ 12:
      return {
        TAG: /* Text */ 1,
        _0: paymentTable.weekly_payment_success_rate,
      };
    case /* NoCol */ 13:
      return {
        TAG: /* Text */ 1,
        _0: "",
      };
  }
}

function getPaymentTable(json) {
  return LogicUtils.getArrayFromJson(json, []).map(function (item) {
    return tableItemToObjMapper(LogicUtils.getDictFromJsonObject(item));
  });
}

function paymentTableEntity(param) {
  return EntityType.makeEntity(
    "" + window._env_.apiBaseUrl + "/analytics/v1/metrics/" + domain + "",
    getPaymentTable,
    AnalyticsTypes.defaultPaymentColumns,
    AnalyticsTypes.allPaymentColumns,
    getUpdatedHeading(undefined, undefined),
    getCell,
    "queryData",
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    [HSAnalyticsUtils.startTimeFilterKey, HSAnalyticsUtils.endTimeFilterKey],
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
  );
}

var singleStateInitialValue = {
  payment_success_rate: 0.0,
  payment_count: 0,
  payment_success_count: 0,
  retries_count: 0,
  retries_amount_processe: 0.0,
  connector_success_rate: 0.0,
  payment_processed_amount: 0.0,
  payment_avg_ticket_size: 0.0,
};

var singleStateSeriesInitialValue = {
  payment_success_rate: 0.0,
  payment_count: 0,
  retries_count: 0,
  retries_amount_processe: 0.0,
  connector_success_rate: 0.0,
  payment_success_count: 0,
  time_series: "",
  payment_processed_amount: 0.0,
  payment_avg_ticket_size: 0.0,
};

function singleStateItemToObjMapper(json) {
  return Core__Option.getOr(
    Core__Option.map(Core__JSON.Decode.object(json), function (dict) {
      return {
        payment_success_rate: LogicUtils.getFloat(
          dict,
          "payment_success_rate",
          0.0,
        ),
        payment_count: LogicUtils.getInt(dict, "payment_count", 0),
        payment_success_count: LogicUtils.getInt(
          dict,
          "payment_success_count",
          0,
        ),
        retries_count: LogicUtils.getInt(dict, "retries_count", 0),
        retries_amount_processe: LogicUtils.getFloat(
          dict,
          "retries_amount_processed",
          0.0,
        ),
        connector_success_rate: LogicUtils.getFloat(
          dict,
          "connector_success_rate",
          0.0,
        ),
        payment_processed_amount: LogicUtils.getFloat(
          dict,
          "payment_processed_amount",
          0.0,
        ),
        payment_avg_ticket_size: LogicUtils.getFloat(
          dict,
          "avg_ticket_size",
          0.0,
        ),
      };
    }),
    singleStateInitialValue,
  );
}

function singleStateSeriesItemToObjMapper(json) {
  return Core__Option.getOr(
    Core__Option.map(Core__JSON.Decode.object(json), function (dict) {
      return {
        payment_success_rate: HSAnalyticsUtils.setPrecision(
          LogicUtils.getFloat(dict, "payment_success_rate", 0.0),
          undefined,
          undefined,
        ),
        payment_count: LogicUtils.getInt(dict, "payment_count", 0),
        retries_count: LogicUtils.getInt(dict, "retries_count", 0),
        retries_amount_processe: LogicUtils.getFloat(
          dict,
          "retries_amount_processed",
          0.0,
        ),
        connector_success_rate: LogicUtils.getFloat(
          dict,
          "connector_success_rate",
          0.0,
        ),
        payment_success_count: LogicUtils.getInt(
          dict,
          "payment_success_count",
          0,
        ),
        time_series: LogicUtils.getString(dict, "time_bucket", ""),
        payment_processed_amount: HSAnalyticsUtils.setPrecision(
          LogicUtils.getFloat(dict, "payment_processed_amount", 0.0),
          undefined,
          undefined,
        ),
        payment_avg_ticket_size: HSAnalyticsUtils.setPrecision(
          LogicUtils.getFloat(dict, "avg_ticket_size", 0.0),
          undefined,
          undefined,
        ),
      };
    }),
    singleStateSeriesInitialValue,
  );
}

function itemToObjMapper(json) {
  var data = HSAnalyticsUtils.getQueryData(json).map(
    singleStateItemToObjMapper,
  );
  var ele = data[0];
  if (ele !== undefined) {
    return ele;
  } else {
    return singleStateInitialValue;
  }
}

function timeSeriesObjMapper(json) {
  return HSAnalyticsUtils.getQueryData(json).map(
    singleStateSeriesItemToObjMapper,
  );
}

function getColumns(connector_success_rate) {
  return [
    {
      sectionName: "",
      columns: connector_success_rate
        ? [
            /* SuccessRate */ 0, /* Count */ 1, /* SuccessCount */ 2,
            /* ProcessedAmount */ 3, /* AvgTicketSize */ 4,
            /* RetriesCount */ 5, /* RetriesAmountProcessed */ 6,
            /* ConnectorSuccessRate */ 7,
          ]
        : [
            /* SuccessRate */ 0, /* Count */ 1, /* SuccessCount */ 2,
            /* ProcessedAmount */ 3, /* AvgTicketSize */ 4,
            /* RetriesCount */ 5, /* RetriesAmountProcessed */ 6,
          ],
    },
  ];
}

function compareLogic(firstValue, secondValue) {
  var temp2 = secondValue[0];
  var temp1 = firstValue[0];
  if (Caml_obj.equal(temp1, temp2)) {
    return 0;
  } else if (Caml_obj.greaterthan(temp1, temp2)) {
    return -1;
  } else {
    return 1;
  }
}

function constructData(key, singlestatTimeseriesData) {
  switch (key) {
    case "connector_success_rate":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.connector_success_rate,
          ];
        })
        .toSorted(compareLogic);
    case "payment_avg_ticket_size":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.payment_avg_ticket_size / 100.0,
          ];
        })
        .toSorted(compareLogic);
    case "payment_count":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [DateTimeUtils.parseAsFloat(ob.time_series), ob.payment_count];
        })
        .toSorted(compareLogic);
    case "payment_processed_amount":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.payment_processed_amount / 100.0,
          ];
        })
        .toSorted(compareLogic);
    case "payment_success_count":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.payment_success_count,
          ];
        })
        .toSorted(compareLogic);
    case "payment_success_rate":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.payment_success_rate,
          ];
        })
        .toSorted(compareLogic);
    case "retries_amount_processed":
      return singlestatTimeseriesData
        .map(function (ob) {
          return [
            DateTimeUtils.parseAsFloat(ob.time_series),
            ob.retries_amount_processe / 100.0,
          ];
        })
        .toSorted(compareLogic);
    case "retries_count":
      return singlestatTimeseriesData.map(function (ob) {
        return [DateTimeUtils.parseAsFloat(ob.time_series), ob.retries_count];
      });
    default:
      return [];
  }
}

function getStatData(
  singleStatData,
  timeSeriesData,
  deltaTimestampData,
  colType,
  _mode,
) {
  switch (colType) {
    case /* SuccessRate */ 0:
      var partial_arg = deltaTimestampData.currentSr;
      var partial_arg$1 = singleStatData.payment_success_rate;
      return {
        title: "Overall Conversion Rate",
        tooltipText:
          "Total successful payments processed out of total payments created (This includes user dropouts at shopping cart and checkout page)",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$1,
            partial_arg,
            param,
          );
        },
        value: singleStatData.payment_success_rate,
        delta: singleStatData.payment_success_rate,
        data: constructData("payment_success_rate", timeSeriesData),
        statType: "Rate",
        showDelta: false,
      };
    case /* Count */ 1:
      var partial_arg$2 = deltaTimestampData.currentSr;
      var partial_arg$3 = singleStatData.payment_count;
      return {
        title: "Overall Payments",
        tooltipText: "Total payments initiated",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$3,
            partial_arg$2,
            param,
          );
        },
        value: singleStatData.payment_count,
        delta: singleStatData.payment_count,
        data: constructData("payment_count", timeSeriesData),
        statType: "Volume",
        showDelta: false,
      };
    case /* SuccessCount */ 2:
      var partial_arg$4 = deltaTimestampData.currentSr;
      var partial_arg$5 = singleStatData.payment_success_count;
      return {
        title: "Success Payments",
        tooltipText: "Total number of payments with status as succeeded. ",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$5,
            partial_arg$4,
            param,
          );
        },
        value: singleStatData.payment_success_count,
        delta: Number(singleStatData.payment_success_count.toFixed(2)),
        data: constructData("payment_success_count", timeSeriesData),
        statType: "Volume",
        showDelta: false,
      };
    case /* ProcessedAmount */ 3:
      var partial_arg$6 = deltaTimestampData.currentSr;
      var partial_arg$7 = singleStatData.payment_processed_amount / 100.0;
      return {
        title: "Processed Amount",
        tooltipText:
          "Sum of amount of all payments with status = succeeded (Please note that there could be payments which could be authorized but not captured. Such payments are not included in the processed amount, because non-captured payments will not be settled to your merchant account by your payment processor)",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$7,
            partial_arg$6,
            param,
          );
        },
        value: singleStatData.payment_processed_amount / 100.0,
        delta: Number(
          (singleStatData.payment_processed_amount / 100.0).toFixed(2),
        ),
        data: constructData("payment_processed_amount", timeSeriesData),
        statType: "Amount",
        showDelta: false,
      };
    case /* AvgTicketSize */ 4:
      var partial_arg$8 = deltaTimestampData.currentSr;
      var partial_arg$9 = singleStatData.payment_avg_ticket_size / 100.0;
      return {
        title: "Avg Ticket Size",
        tooltipText:
          "The total amount for which payments were created divided by the total number of payments created.",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$9,
            partial_arg$8,
            param,
          );
        },
        value: singleStatData.payment_avg_ticket_size / 100.0,
        delta: Number(
          (singleStatData.payment_avg_ticket_size / 100.0).toFixed(2),
        ),
        data: constructData("payment_avg_ticket_size", timeSeriesData),
        statType: "Volume",
        showDelta: false,
      };
    case /* RetriesCount */ 5:
      var partial_arg$10 = deltaTimestampData.currentSr;
      var partial_arg$11 = singleStatData.retries_count;
      return {
        title: "Smart Retries made",
        tooltipText:
          "Total number of retries that were attempted after a failed payment attempt (Note: Only date range filters are supoorted currently)",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$11,
            partial_arg$10,
            param,
          );
        },
        value: singleStatData.retries_count,
        delta: singleStatData.retries_count,
        data: constructData("retries_count", timeSeriesData),
        statType: "Volume",
        showDelta: false,
      };
    case /* RetriesAmountProcessed */ 6:
      var partial_arg$12 = deltaTimestampData.currentSr;
      var partial_arg$13 = singleStatData.retries_amount_processe / 100.0;
      return {
        title: "Smart Retries Savings",
        tooltipText:
          "Total savings in amount terms from retrying failed payments again through a second processor (Note: Only date range filters are supoorted currently)",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$13,
            partial_arg$12,
            param,
          );
        },
        value: singleStatData.retries_amount_processe / 100.0,
        delta: Number(
          (singleStatData.retries_amount_processe / 100.0).toFixed(2),
        ),
        data: constructData("retries_amount_processe", timeSeriesData),
        statType: "Amount",
        showDelta: false,
      };
    case /* ConnectorSuccessRate */ 7:
      var partial_arg$14 = deltaTimestampData.currentSr;
      var partial_arg$15 = singleStatData.connector_success_rate;
      return {
        title: "Payment Success Rate",
        tooltipText:
          "Total successful payments processed out of all user confirmed payments",
        deltaTooltipComponent: function (param) {
          return AnalyticsUtils.singlestatDeltaTooltipFormat(
            partial_arg$15,
            partial_arg$14,
            param,
          );
        },
        value: singleStatData.connector_success_rate,
        delta: singleStatData.connector_success_rate,
        data: constructData("connector_success_rate", timeSeriesData),
        statType: "Rate",
        showDelta: false,
      };
  }
}

function getSingleStatEntity(metrics, connector_success_rate) {
  return {
    urlConfig: [
      {
        uri:
          "" + window._env_.apiBaseUrl + "/analytics/v1/metrics/" + domain + "",
        metrics: HSAnalyticsUtils.getStringListFromArrayDict(metrics),
      },
    ],
    getObjects: itemToObjMapper,
    getTimeSeriesObject: timeSeriesObjMapper,
    defaultColumns: getColumns(connector_success_rate),
    getData: getStatData,
    matrixUriMapper: function (param) {
      return (
        "" + window._env_.apiBaseUrl + "/analytics/v1/metrics/" + domain + ""
      );
    },
  };
}

var metricsConfig = [
  {
    metric_name_db: "payment_count",
    metric_label: "Volume",
    metric_type: /* Volume */ 1,
    legendOption: [/* Average */ 2, /* Overall */ 1],
  },
  {
    metric_name_db: "payment_success_rate",
    metric_label: "Success Rate",
    metric_type: /* Rate */ 2,
    legendOption: [/* Current */ 3, /* Overall */ 1],
  },
  {
    metric_name_db: "payment_processed_amount",
    metric_label: "Processed Amount",
    metric_type: /* Volume */ 1,
    legendOption: [/* Average */ 2, /* Overall */ 1],
  },
];

function chartEntity(tabKeys) {
  return DynamicChart.makeEntity(
    {
      TAG: /* String */ 0,
      _0: "" + window._env_.apiBaseUrl + "/analytics/v1/metrics/" + domain + "",
    },
    undefined,
    tabKeys,
    [HSAnalyticsUtils.startTimeFilterKey, HSAnalyticsUtils.endTimeFilterKey],
    ["Success Rate", "Volume"],
    [],
    [],
    [/* Line */ 0],
    [
      {
        uri:
          "" + window._env_.apiBaseUrl + "/analytics/v1/metrics/" + domain + "",
        timeSeriesBody: DynamicChart.getTimeSeriesChart,
        legendBody: DynamicChart.getLegendBody,
        metrics: metricsConfig,
        timeCol: "time_bucket",
        filterKeys: tabKeys,
      },
    ],
    "Payment Analytics",
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
  );
}

var makeMultiInputFieldInfo = FormRenderer.makeMultiInputFieldInfo;

var makeInputFieldInfo = FormRenderer.makeInputFieldInfo;

var makeFieldInfo = FormRenderer.makeFieldInfo;

export {
  domain,
  makeMultiInputFieldInfo,
  makeInputFieldInfo,
  colMapper,
  reverseColMapper,
  weeklyTableMetricsCols,
  percentFormat,
  getWeeklySR,
  distribution,
  tableItemToObjMapper,
  getUpdatedHeading,
  getCell,
  getPaymentTable,
  makeFieldInfo,
  paymentTableEntity,
  singleStateInitialValue,
  singleStateSeriesInitialValue,
  singleStateItemToObjMapper,
  singleStateSeriesItemToObjMapper,
  itemToObjMapper,
  timeSeriesObjMapper,
  getColumns,
  compareLogic,
  constructData,
  getStatData,
  getSingleStatEntity,
  metricsConfig,
  chartEntity,
};
/* distribution Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Fetch from "bs-fetch/src/Fetch.bs.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";

function useAddLogsAroundFetch(param) {
  return function (setStatusDict, logTitle, fetchPromise) {
    var setStatusDict$1 =
      setStatusDict !== undefined ? setStatusDict : function (param) {};
    Curry._1(setStatusDict$1, function (prev) {
      return Object.fromEntries(
        Object.entries(prev).filter(function (entry) {
          return entry[0] !== logTitle;
        }),
      );
    });
    return Core__Promise.$$catch(
      fetchPromise
        .then(function (resp) {
          var status = resp.status;
          Curry._1(setStatusDict$1, function (prev) {
            prev[logTitle] = status;
            return prev;
          });
          if (status >= 400) {
            return Promise.reject(Js_exn.raiseError("err"));
          } else {
            return Promise.resolve(resp);
          }
        })
        .then(Fetch.$$Response.json)
        .then(function (json) {
          return json;
        }),
      function (err) {
        return Promise.reject(err);
      },
    );
  };
}

function useAddLogsAroundFetchNew(param) {
  return function (setStatusDict, logTitle, fetchPromise) {
    var setStatusDict$1 =
      setStatusDict !== undefined ? setStatusDict : function (param) {};
    Curry._1(setStatusDict$1, function (prev) {
      return Object.fromEntries(
        Object.entries(prev).filter(function (entry) {
          return entry[0] !== logTitle;
        }),
      );
    });
    return Core__Promise.$$catch(
      fetchPromise
        .then(function (resp) {
          var status = resp.status;
          Curry._1(setStatusDict$1, function (prev) {
            prev[logTitle] = status;
            return prev;
          });
          if (status >= 400) {
            return Promise.reject(Js_exn.raiseError("err"));
          } else {
            return Promise.resolve(resp);
          }
        })
        .then(Fetch.$$Response.text)
        .then(function (text) {
          return text;
        }),
      function (err) {
        return Promise.reject(err);
      },
    );
  };
}

export { useAddLogsAroundFetch, useAddLogsAroundFetchNew };
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../Icon.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as UIUtils from "../../utils/UIUtils.bs.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as ThemeProvider from "../../context/ThemeProvider.bs.js";
import * as AddDataAttributes from "../AddDataAttributes.bs.js";
import * as JsxPPXReactSupport from "rescript/lib/es6/jsxPPXReactSupport.js";

function ToolTip$TooltipMainWrapper(props) {
  var setIsToolTipVisible = props.setIsToolTipVisible;
  var hoverOnToolTip = props.hoverOnToolTip;
  var visibleOnClick = props.visibleOnClick;
  var relativeClass = props.isRelative ? "relative" : "";
  var flexCss = hoverOnToolTip ? "inline-flex" : "flex";
  var alignClass;
  switch (props.contentAlign) {
    case /* Left */ 0:
      alignClass = "items-start";
      break;
    case /* Right */ 1:
      alignClass = "items-end";
      break;
    case /* Middle */ 2:
      alignClass = "items-center";
      break;
    case /* Default */ 3:
      alignClass = "";
      break;
  }
  var timeoutRef = React.useRef(undefined);
  var handleMouseOver = function (_evt) {
    if (visibleOnClick) {
      return;
    }
    var timerId = timeoutRef.current;
    if (timerId !== undefined) {
      clearTimeout(Caml_option.valFromOption(timerId));
    }
    Curry._1(setIsToolTipVisible, function (param) {
      return true;
    });
  };
  var handleClick = function (_evt) {
    if (!visibleOnClick) {
      return;
    }
    var timerId = timeoutRef.current;
    if (timerId !== undefined) {
      clearTimeout(Caml_option.valFromOption(timerId));
    }
    Curry._1(setIsToolTipVisible, function (param) {
      return true;
    });
  };
  var handleMouseOut = function (_evt) {
    if (hoverOnToolTip) {
      timeoutRef.current = Caml_option.some(
        setTimeout(function (param) {
          Curry._1(setIsToolTipVisible, function (param) {
            return false;
          });
        }, 200),
      );
      return;
    } else {
      return Curry._1(setIsToolTipVisible, function (param) {
        return false;
      });
    }
  };
  return React.createElement(AddDataAttributes.make, {
    attributes: [["data-tooltip", "tooltip"]],
    children: React.createElement(
      "div",
      {
        className:
          "" +
          relativeClass +
          " " +
          flexCss +
          " " +
          props.flexClass +
          " " +
          props.height +
          " " +
          alignClass +
          " " +
          props.justifyClass +
          "",
        onClick: handleClick,
        onMouseOut: handleMouseOut,
        onMouseOver: handleMouseOver,
      },
      props.children,
    ),
  });
}

function getToolTipFixedStyling(
  hoverOnToolTip,
  positionX,
  positionY,
  tooltipWidth,
  tooltipHeight,
  tooltipArrowSize,
  componentWidth,
  componentHeight,
  position,
) {
  var toolTipTopPosition;
  var exit = 0;
  switch (position) {
    case /* Top */ 0:
      toolTipTopPosition = hoverOnToolTip
        ? (((((((positionY - tooltipHeight) | 0) - 4) | 0) -
            ((tooltipArrowSize - 5) | 0)) |
            0) -
            4) |
          0
        : (((((positionY - tooltipHeight) | 0) - 4) | 0) - 4) | 0;
      break;
    case /* Bottom */ 1:
      toolTipTopPosition = hoverOnToolTip
        ? (((((((positionY + componentHeight) | 0) + 4) | 0) +
            ((tooltipArrowSize - 5) | 0)) |
            0) +
            4) |
          0
        : (((((positionY + componentHeight) | 0) + 4) | 0) + 4) | 0;
      break;
    case /* Left */ 2:
    case /* Right */ 3:
      exit = 1;
      break;
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      exit = 3;
      break;
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      toolTipTopPosition =
        (((positionY - ((tooltipHeight / 2) | 0)) | 0) +
          ((componentHeight / 2) | 0)) |
        0;
      break;
    case 2:
      toolTipTopPosition =
        (((((positionY + componentHeight) | 0) + 4) | 0) + 4) | 0;
      break;
    case 3:
      toolTipTopPosition =
        (((((positionY - tooltipHeight) | 0) - 4) | 0) - 4) | 0;
      break;
  }
  var toolTipLeftPosition;
  var exit$1 = 0;
  switch (position) {
    case /* Top */ 0:
    case /* Bottom */ 1:
      exit$1 = 1;
      break;
    case /* Left */ 2:
      toolTipLeftPosition = hoverOnToolTip
        ? (((((((((positionX - tooltipWidth) | 0) - 4) | 0) + 2) | 0) -
            ((tooltipArrowSize - 5) | 0)) |
            0) -
            4) |
          0
        : (((((((positionX - tooltipWidth) | 0) - 4) | 0) + 2) | 0) - 4) | 0;
      break;
    case /* Right */ 3:
      toolTipLeftPosition = hoverOnToolTip
        ? (((((((positionX + componentWidth) | 0) + 4) | 0) +
            ((tooltipArrowSize - 5) | 0)) |
            0) +
            4) |
          0
        : (((((positionX + componentWidth) | 0) + 4) | 0) + 4) | 0;
      break;
    case /* TopLeft */ 5:
    case /* BottomLeft */ 6:
      exit$1 = 2;
      break;
    case /* TopRight */ 4:
    case /* BottomRight */ 7:
      exit$1 = 3;
      break;
  }
  switch (exit$1) {
    case 1:
      toolTipLeftPosition =
        (((positionX - ((tooltipWidth / 2) | 0)) | 0) +
          ((componentWidth / 2) | 0)) |
        0;
      break;
    case 2:
      toolTipLeftPosition =
        (((((positionX + ((componentWidth / 2) | 0)) | 0) - tooltipWidth) | 0) +
          9) |
        0;
      break;
    case 3:
      toolTipLeftPosition =
        (((positionX + ((componentWidth / 2) | 0)) | 0) - 9) | 0;
      break;
  }
  return {
    left: "" + toolTipLeftPosition.toString() + "px",
    top: "" + toolTipTopPosition.toString() + "px",
  };
}

function getToolTipAbsoluteStyling(
  tooltipArrowHeight,
  tooltipHeightFloat,
  tooltipArrowWidth,
  tooltipWidth,
  componentWidth,
  componentHeight,
  position,
) {
  var toolTipTopPosition;
  var exit = 0;
  switch (position) {
    case /* Left */ 2:
    case /* Right */ 3:
      exit = 3;
      break;
    case /* Top */ 0:
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      exit = 1;
      break;
    case /* Bottom */ 1:
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      toolTipTopPosition =
        (tooltipArrowHeight / componentHeight) * -100.0 +
        (tooltipHeightFloat / componentHeight) * -100.0;
      break;
    case 2:
      toolTipTopPosition =
        100.0 + (tooltipArrowHeight / componentHeight) * 100.0;
      break;
    case 3:
      toolTipTopPosition = 50.0 - (tooltipHeightFloat / componentHeight) * 50.0;
      break;
  }
  var toolTipLeftPosition;
  var exit$1 = 0;
  switch (position) {
    case /* Top */ 0:
    case /* Bottom */ 1:
      exit$1 = 1;
      break;
    case /* Left */ 2:
      toolTipLeftPosition =
        (tooltipArrowWidth / componentWidth) * -100.0 +
        (tooltipWidth / componentWidth) * -100.0;
      break;
    case /* Right */ 3:
      toolTipLeftPosition =
        100.0 + (tooltipArrowWidth / componentWidth) * 100.0;
      break;
    case /* TopLeft */ 5:
    case /* BottomLeft */ 6:
      toolTipLeftPosition = (tooltipWidth / componentWidth) * -50.0;
      break;
    case /* TopRight */ 4:
    case /* BottomRight */ 7:
      exit$1 = 2;
      break;
  }
  switch (exit$1) {
    case 1:
      toolTipLeftPosition = 50.0 - (tooltipWidth / componentWidth) * 50.0;
      break;
    case 2:
      toolTipLeftPosition = 100.0 + (tooltipWidth / componentWidth) * -60.0;
      break;
  }
  return {
    left: "" + toolTipLeftPosition.toString() + "%",
    top: "" + toolTipTopPosition.toString() + "%",
  };
}

function ToolTip$TooltipWrapper(props) {
  var defaultPosition = props.defaultPosition;
  var toolTipPosition = props.toolTipPosition;
  var componentHeight = props.componentHeight;
  var componentWidth = props.componentWidth;
  var tooltipWidth = props.tooltipWidth;
  var tooltipPositioning = props.tooltipPositioning;
  var hoverOnToolTip = props.hoverOnToolTip;
  var isToolTipVisible = props.isToolTipVisible;
  var descriptionExists =
    LogicUtils.isNonEmptyString(props.description) ||
    Caml_obj.notequal(props.descriptionComponent, null);
  var tooltipOpacity =
    isToolTipVisible && descriptionExists ? "opacity-100" : "opacity-0";
  var pointerEvents =
    isToolTipVisible && hoverOnToolTip ? "" : " pointer-events-none";
  var toolTipPositionString =
    tooltipPositioning === "fixed"
      ? "fixed"
      : tooltipPositioning === "static"
        ? "static"
        : "absolute";
  var tooltipPositionStyle =
    tooltipPositioning === "fixed"
      ? getToolTipFixedStyling(
          hoverOnToolTip,
          props.positionX,
          props.positionY,
          tooltipWidth,
          props.tooltipHeight,
          props.tooltipArrowSize,
          componentWidth,
          componentHeight,
          Core__Option.getOr(toolTipPosition, defaultPosition),
        )
      : getToolTipAbsoluteStyling(
          props.tooltipArrowHeight,
          props.tooltipHeightFloat,
          props.tooltipArrowWidth,
          tooltipWidth,
          componentWidth,
          componentHeight,
          Core__Option.getOr(toolTipPosition, defaultPosition),
        );
  return React.createElement(
    "div",
    {
      className: "" + tooltipOpacity + " " + pointerEvents + "",
    },
    React.createElement(
      "div",
      {
        ref: Caml_option.some(props.toolTipRef),
        className:
          "" +
          toolTipPositionString +
          " " +
          props.tooltipWidthClass +
          " z-30 h-auto break-words",
        style: Object.assign({}, tooltipPositionStyle, {
          hyphens: "auto",
        }),
      },
      React.createElement(
        "div",
        {
          className:
            "relative whitespace-pre-line max-w-xs text-left p-3 " +
            props.textStyle +
            " font-semibold rounded " +
            props.bgColor +
            " " +
            props.customStyle +
            "",
        },
        props.children,
      ),
    ),
  );
}

function ToolTip$DescriptionSection(props) {
  var setIsToolTipVisible = props.setIsToolTipVisible;
  return React.createElement(
    "div",
    {
      className: props.textStyleGap,
    },
    props.description
      .split("\n")
      .filter(LogicUtils.isNonEmptyString)
      .map(function (item, i) {
        return JsxPPXReactSupport.createElementWithKey(
          i.toString(),
          AddDataAttributes.make,
          {
            attributes: [["data-text", item]],
            children: React.createElement(
              "div",
              {
                key: item,
                className: "flex flex-col gap-1",
              },
              item,
            ),
          },
        );
      }),
    React.createElement(
      "div",
      {
        className: props.descriptionComponentClass,
      },
      React.createElement(UIUtils.RenderIf.make, {
        condition: props.dismissable,
        children: React.createElement(Icon.make, {
          name: "popUpClose",
          size: 20,
          className: "stroke-jp-2-dark-gray-2000 cursor-pointer",
          onClick: function (param) {
            Curry._1(setIsToolTipVisible, function (prev) {
              return !prev;
            });
          },
          parentClass: "mt-5 mr-4",
        }),
      }),
      props.descriptionComponent,
    ),
  );
}

function ToolTip$TooltipFor(props) {
  var toolTipFor = props.toolTipFor;
  return React.createElement(
    "div",
    {
      ref: Caml_option.some(props.componentRef),
      className: "inline h-min desktop:flex " + props.tooltipForWidthClass + "",
    },
    toolTipFor !== undefined
      ? Caml_option.valFromOption(toolTipFor)
      : React.createElement(Icon.make, {
          name: "tooltip_info",
          size: 16,
          className:
            "opacity-50 hover:opacity-100 dark:brightness-50 dark:opacity-35 dark:invert dark:hover:opacity-70 ",
        }),
  );
}

function getArrowFixedPosition(
  hoverOnToolTip,
  positionX,
  positionY,
  tooltipArrowSize,
  componentWidth,
  componentHeight,
  arrowColor,
  position,
) {
  var arrowTopPosition;
  var exit = 0;
  switch (position) {
    case /* Top */ 0:
      arrowTopPosition = hoverOnToolTip
        ? (((((positionY - 4) | 0) - ((tooltipArrowSize - 5) | 0)) | 0) - 5) | 0
        : (((positionY - 4) | 0) - 5) | 0;
      break;
    case /* Left */ 2:
    case /* Right */ 3:
      exit = 1;
      break;
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      arrowTopPosition = (((positionY - 4) | 0) - 4) | 0;
      break;
    case /* Bottom */ 1:
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      arrowTopPosition =
        (((positionY + ((componentHeight / 2) | 0)) | 0) - 4) | 0;
      break;
    case 2:
      arrowTopPosition = (((positionY + componentHeight) | 0) + 4) | 0;
      break;
  }
  var arrowLeftPosition =
    position !== 2
      ? position !== 3
        ? (((positionX + ((componentWidth / 2) | 0)) | 0) - 5) | 0
        : (((positionX + componentWidth) | 0) + 4) | 0
      : hoverOnToolTip
        ? (((((positionX - 4) | 0) - ((tooltipArrowSize - 5) | 0)) | 0) - 4) | 0
        : (((positionX - 4) | 0) - 4) | 0;
  var tooltipArrowpixel = "" + tooltipArrowSize.toString() + "px";
  var borderWidth;
  switch (position) {
    case /* Left */ 2:
      borderWidth =
        "" +
        tooltipArrowpixel +
        " 0 " +
        tooltipArrowpixel +
        " " +
        tooltipArrowpixel +
        "";
      break;
    case /* Right */ 3:
      borderWidth =
        "" +
        tooltipArrowpixel +
        " " +
        tooltipArrowpixel +
        " " +
        tooltipArrowpixel +
        " 0";
      break;
    case /* Top */ 0:
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      borderWidth = "" + tooltipArrowpixel + " " + tooltipArrowpixel + " 0";
      break;
    case /* Bottom */ 1:
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      borderWidth = "0 " + tooltipArrowpixel + " " + tooltipArrowpixel + "";
      break;
  }
  var borderTopColor =
    position === /* Top */ 0 ||
    position === /* TopLeft */ 5 ||
    position === /* TopRight */ 4
      ? arrowColor
      : "transparent";
  var borderRightColor =
    position === /* Right */ 3 ? arrowColor : "transparent";
  var borderBottomColor =
    position === /* Bottom */ 1 ||
    position === /* BottomLeft */ 6 ||
    position === /* BottomRight */ 7
      ? arrowColor
      : "transparent";
  var borderLeftColor = position === /* Left */ 2 ? arrowColor : "transparent";
  return {
    borderTopColor: borderTopColor,
    borderRightColor: borderRightColor,
    borderBottomColor: borderBottomColor,
    borderLeftColor: borderLeftColor,
    borderWidth: borderWidth,
    height: "0",
    left: "" + arrowLeftPosition.toString() + "px",
    top: "" + arrowTopPosition.toString() + "px",
    width: "0",
  };
}

function getArrowAbsolutePosition(
  tooltipArrowWidth,
  tooltipArrowHeight,
  tooltipHeightFloat,
  tooltipWidth,
  arrowColor,
  position,
) {
  var arrowTopPosition;
  var exit = 0;
  switch (position) {
    case /* Left */ 2:
    case /* Right */ 3:
      exit = 3;
      break;
    case /* Top */ 0:
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      exit = 1;
      break;
    case /* Bottom */ 1:
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      arrowTopPosition =
        100.0 - (tooltipArrowHeight / tooltipHeightFloat) * -10.0;
      break;
    case 2:
      arrowTopPosition = (tooltipArrowHeight / tooltipHeightFloat) * -100.0;
      break;
    case 3:
      arrowTopPosition =
        50.0 - (tooltipArrowHeight / tooltipHeightFloat) * 50.0;
      break;
  }
  var arrowLeftPosition =
    position !== 2
      ? position !== 3
        ? 50.0 - (tooltipArrowWidth / tooltipWidth) * 50.0
        : (tooltipArrowWidth / tooltipWidth) * -100.0
      : 100.0 + tooltipArrowWidth / tooltipWidth;
  var borderWidth;
  switch (position) {
    case /* Left */ 2:
      borderWidth = "5px 0 5px 5px";
      break;
    case /* Right */ 3:
      borderWidth = "5px 5px 5px 0";
      break;
    case /* Top */ 0:
    case /* TopRight */ 4:
    case /* TopLeft */ 5:
      borderWidth = "5px 5px 0";
      break;
    case /* Bottom */ 1:
    case /* BottomLeft */ 6:
    case /* BottomRight */ 7:
      borderWidth = "0 5px 5px";
      break;
  }
  var borderTopColor =
    position === /* Top */ 0 ||
    position === /* TopLeft */ 5 ||
    position === /* TopRight */ 4
      ? arrowColor
      : "transparent";
  var borderRightColor =
    position === /* Right */ 3 ? arrowColor : "transparent";
  var borderBottomColor =
    position === /* Bottom */ 1 ||
    position === /* BottomLeft */ 6 ||
    position === /* BottomRight */ 7
      ? arrowColor
      : "transparent";
  var borderLeftColor = position === /* Left */ 2 ? arrowColor : "transparent";
  return {
    borderTopColor: borderTopColor,
    borderRightColor: borderRightColor,
    borderBottomColor: borderBottomColor,
    borderLeftColor: borderLeftColor,
    borderWidth: borderWidth,
    height: "0",
    left: "" + arrowLeftPosition.toString() + "%",
    top: "" + arrowTopPosition.toString() + "%",
    width: "0",
  };
}

function ToolTip$Arrow(props) {
  var arrowBgClass = props.arrowBgClass;
  var componentHeight = props.componentHeight;
  var componentWidth = props.componentWidth;
  var tooltipArrowSize = props.tooltipArrowSize;
  var positionY = props.positionY;
  var positionX = props.positionX;
  var hoverOnToolTip = props.hoverOnToolTip;
  var toolTipPosition = props.toolTipPosition;
  var tooltipPositioning = props.tooltipPositioning;
  var theme = ThemeProvider.useTheme(undefined);
  var arrowBackGroundClass = theme ? "#fff" : "#000";
  var arrowColor =
    LogicUtils.isNonEmptyString(arrowBgClass) &&
    LogicUtils.isNonEmptyString(props.bgColor)
      ? arrowBgClass
      : arrowBackGroundClass;
  var tooltipArrowPosition =
    toolTipPosition !== undefined
      ? tooltipPositioning === "fixed"
        ? getArrowFixedPosition(
            hoverOnToolTip,
            positionX,
            positionY,
            tooltipArrowSize,
            componentWidth,
            componentHeight,
            arrowColor,
            toolTipPosition,
          )
        : getArrowAbsolutePosition(
            props.tooltipArrowWidth,
            props.tooltipArrowHeight,
            props.tooltipHeightFloat,
            props.tooltipWidth,
            arrowColor,
            toolTipPosition,
          )
      : getArrowFixedPosition(
          hoverOnToolTip,
          positionX,
          positionY,
          tooltipArrowSize,
          componentWidth,
          componentHeight,
          arrowColor,
          props.defaultPosition,
        );
  var toolTipPositionString =
    tooltipPositioning === "fixed"
      ? "fixed"
      : tooltipPositioning === "static"
        ? "static"
        : "absolute";
  return React.createElement("div", {
    ref: Caml_option.some(props.toolTipArrowRef),
    className:
      "" +
      props.arrowCustomStyle +
      " " +
      toolTipPositionString +
      " border-solid z-30 w-auto",
    style: tooltipArrowPosition,
  });
}

function getDefaultPosition(
  positionX,
  positionY,
  componentWidth,
  componentHeight,
  tooltipWidth,
  tooltipHeight,
) {
  var tBoundingMidHeight = (((componentHeight + tooltipHeight) | 0) / 2) | 0;
  var tBoundingMidWidth = (((componentWidth + tooltipWidth) | 0) / 2) | 0;
  if (((window.innerWidth / 2) | 0) > positionX) {
    if (window.innerHeight < ((tBoundingMidHeight + positionY) | 0)) {
      if (positionX < tBoundingMidWidth) {
        return /* TopRight */ 4;
      } else {
        return /* Top */ 0;
      }
    } else if (0 < ((tBoundingMidHeight - positionY) | 0)) {
      if (positionX < tBoundingMidWidth) {
        return /* BottomRight */ 7;
      } else {
        return /* Bottom */ 1;
      }
    } else {
      return /* Right */ 3;
    }
  } else if (window.innerHeight < ((tBoundingMidHeight + positionY) | 0)) {
    if (window.innerWidth < ((positionX + tBoundingMidWidth) | 0)) {
      return /* TopLeft */ 5;
    } else {
      return /* Top */ 0;
    }
  } else if (0 < ((tBoundingMidHeight - positionY) | 0)) {
    if (window.innerWidth < ((positionX + tBoundingMidWidth) | 0)) {
      return /* BottomLeft */ 6;
    } else {
      return /* Bottom */ 1;
    }
  } else {
    return /* Left */ 2;
  }
}

function ToolTip(props) {
  var dismissable = props.dismissable;
  var isRelative = props.isRelative;
  var descriptionComponentClass = props.descriptionComponentClass;
  var visibleOnClick = props.visibleOnClick;
  var tooltipArrowSize = props.tooltipArrowSize;
  var hoverOnToolTip = props.hoverOnToolTip;
  var textStyle = props.textStyle;
  var height = props.height;
  var flexClass = props.flexClass;
  var justifyClass = props.justifyClass;
  var contentAlign = props.contentAlign;
  var bgColor = props.bgColor;
  var arrowBgClass = props.arrowBgClass;
  var textStyleGap = props.textStyleGap;
  var arrowCustomStyle = props.arrowCustomStyle;
  var customStyle = props.customStyle;
  var toolTipPosition = props.toolTipPosition;
  var tooltipForWidthClass = props.tooltipForWidthClass;
  var tooltipWidthClass = props.tooltipWidthClass;
  var tooltipPositioning = props.tooltipPositioning;
  var descriptionComponent = props.descriptionComponent;
  var description = props.description;
  var description$1 = description !== undefined ? description : "";
  var descriptionComponent$1 =
    descriptionComponent !== undefined
      ? Caml_option.valFromOption(descriptionComponent)
      : null;
  var tooltipPositioning$1 =
    tooltipPositioning !== undefined ? tooltipPositioning : "fixed";
  var tooltipWidthClass$1 =
    tooltipWidthClass !== undefined ? tooltipWidthClass : "w-fit";
  var tooltipForWidthClass$1 =
    tooltipForWidthClass !== undefined ? tooltipForWidthClass : "";
  var customStyle$1 = customStyle !== undefined ? customStyle : "";
  var arrowCustomStyle$1 =
    arrowCustomStyle !== undefined ? arrowCustomStyle : "";
  var textStyleGap$1 = textStyleGap !== undefined ? textStyleGap : "";
  var arrowBgClass$1 = arrowBgClass !== undefined ? arrowBgClass : "";
  var bgColor$1 = bgColor !== undefined ? bgColor : "";
  var contentAlign$1 =
    contentAlign !== undefined ? contentAlign : /* Middle */ 2;
  var justifyClass$1 =
    justifyClass !== undefined ? justifyClass : "justify-center";
  var flexClass$1 = flexClass !== undefined ? flexClass : "flex-col";
  var height$1 = height !== undefined ? height : "h-full";
  var textStyle$1 = textStyle !== undefined ? textStyle : "text-fs-11";
  var hoverOnToolTip$1 = hoverOnToolTip !== undefined ? hoverOnToolTip : false;
  var tooltipArrowSize$1 =
    tooltipArrowSize !== undefined ? tooltipArrowSize : 5;
  var visibleOnClick$1 = visibleOnClick !== undefined ? visibleOnClick : false;
  var descriptionComponentClass$1 =
    descriptionComponentClass !== undefined
      ? descriptionComponentClass
      : "flex flex-row-reverse";
  var isRelative$1 = isRelative !== undefined ? isRelative : true;
  var dismissable$1 = dismissable !== undefined ? dismissable : false;
  var match = React.useState(function () {
    return false;
  });
  var setIsToolTipVisible = match[1];
  var isToolTipVisible = match[0];
  var toolTipRef = React.useRef(null);
  var componentRef = React.useRef(null);
  var toolTipArrowRef = React.useRef(null);
  React.useEffect(
    function () {
      if (!isToolTipVisible) {
        return;
      }
      var handleScroll = function (_e) {
        Curry._1(setIsToolTipVisible, function (param) {
          return false;
        });
      };
      window.addEventListener("scroll", handleScroll, true);
      return function (param) {
        window.removeEventListener("scroll", handleScroll);
      };
    },
    [isToolTipVisible],
  );
  var getBoundingRectInfo = function (ref, getter) {
    return Core__Option.mapOr(
      Core__Option.map(
        Caml_option.nullable_to_opt(ref.current),
        function (prim) {
          return prim.getBoundingClientRect();
        },
      ),
      0,
      getter,
    );
  };
  var tooltipWidth = getBoundingRectInfo(toolTipRef, function (val) {
    return val.width;
  });
  var tooltipHeight = getBoundingRectInfo(toolTipRef, function (val) {
    return val.height;
  });
  var tooltipArrowWidth = getBoundingRectInfo(toolTipArrowRef, function (val) {
    return val.width;
  });
  var tooltipArrowHeight = getBoundingRectInfo(toolTipArrowRef, function (val) {
    return val.height;
  });
  var positionX = getBoundingRectInfo(componentRef, function (val) {
    return val.x;
  });
  var positionY = getBoundingRectInfo(componentRef, function (val) {
    return val.y;
  });
  var componentWidth = getBoundingRectInfo(componentRef, function (val) {
    return val.width;
  });
  var componentHeight = getBoundingRectInfo(componentRef, function (val) {
    return val.height;
  });
  var bgColor$2 = LogicUtils.isEmptyString(bgColor$1)
    ? "dark:bg-jp-gray-tooltip_bg_dark bg-jp-gray-tooltip_bg_light dark:text-jp-gray-lightgray_background dark:text-opacity-75 text-jp-gray-text_darktheme text-opacity-75"
    : bgColor$1;
  var defaultPosition = getDefaultPosition(
    positionX,
    positionY,
    componentWidth,
    componentHeight,
    tooltipWidth,
    tooltipHeight,
  );
  return React.createElement(
    ToolTip$TooltipMainWrapper,
    {
      children: null,
      visibleOnClick: visibleOnClick$1,
      hoverOnToolTip: hoverOnToolTip$1,
      setIsToolTipVisible: setIsToolTipVisible,
      isRelative: isRelative$1,
      flexClass: flexClass$1,
      height: height$1,
      contentAlign: contentAlign$1,
      justifyClass: justifyClass$1,
    },
    React.createElement(ToolTip$TooltipFor, {
      toolTipFor: props.toolTipFor,
      tooltipForWidthClass: tooltipForWidthClass$1,
      componentRef: componentRef,
    }),
    React.createElement(
      ToolTip$TooltipWrapper,
      {
        isToolTipVisible: isToolTipVisible,
        descriptionComponent: descriptionComponent$1,
        description: description$1,
        hoverOnToolTip: hoverOnToolTip$1,
        tooltipPositioning: tooltipPositioning$1,
        tooltipWidthClass: tooltipWidthClass$1,
        toolTipRef: toolTipRef,
        textStyle: textStyle$1,
        bgColor: bgColor$2,
        customStyle: customStyle$1,
        positionX: positionX,
        positionY: positionY,
        tooltipArrowHeight: tooltipArrowHeight,
        tooltipHeightFloat: tooltipHeight,
        tooltipArrowWidth: tooltipArrowWidth,
        tooltipWidth: tooltipWidth,
        tooltipHeight: tooltipHeight,
        tooltipArrowSize: tooltipArrowSize$1,
        componentWidth: componentWidth,
        componentHeight: componentHeight,
        toolTipPosition: toolTipPosition,
        defaultPosition: defaultPosition,
        children: null,
      },
      React.createElement(ToolTip$DescriptionSection, {
        description: description$1,
        descriptionComponent: descriptionComponent$1,
        textStyleGap: textStyleGap$1,
        descriptionComponentClass: descriptionComponentClass$1,
        setIsToolTipVisible: setIsToolTipVisible,
        dismissable: dismissable$1,
      }),
      React.createElement(ToolTip$Arrow, {
        toolTipArrowRef: toolTipArrowRef,
        arrowCustomStyle: arrowCustomStyle$1,
        tooltipPositioning: tooltipPositioning$1,
        toolTipPosition: toolTipPosition,
        hoverOnToolTip: hoverOnToolTip$1,
        positionX: positionX,
        positionY: positionY,
        tooltipArrowWidth: tooltipArrowWidth,
        tooltipArrowHeight: tooltipArrowHeight,
        tooltipHeightFloat: tooltipHeight,
        tooltipArrowSize: tooltipArrowSize$1,
        tooltipWidth: tooltipWidth,
        componentWidth: componentWidth,
        componentHeight: componentHeight,
        bgColor: bgColor$2,
        arrowBgClass: arrowBgClass$1,
        defaultPosition: defaultPosition,
      }),
    ),
  );
}

var make = ToolTip;

export { make };
/* Icon Not a pure module */

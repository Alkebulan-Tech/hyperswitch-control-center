// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "./Icon.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Shimmer from "../libraries/Shimmer.bs.js";
import * as AuthHooks from "../hooks/AuthHooks.bs.js";
import * as SelectBox from "./SelectBox.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as MatchMedia from "../context/MatchMedia.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as FunnelChart from "./CustomCharts/FunnelChart.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as TimeZoneHook from "../hooks/TimeZoneHook.bs.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";
import * as FilterContext from "../context/FilterContext.bs.js";
import * as ThemeProvider from "../context/ThemeProvider.bs.js";
import * as UrlFetchUtils from "../utils/UrlFetchUtils.bs.js";
import * as AnalyticsUtils from "../entities/analytics/AnalyticsUtils.bs.js";
import * as LineChartUtils from "./CustomCharts/LineChartUtils.bs.js";
import * as ReactFinalForm from "../libraries/ReactFinalForm.bs.js";
import * as ReactFinalForm$1 from "react-final-form";
import * as AddDataAttributes from "./AddDataAttributes.bs.js";
import * as HighchartBarChart from "./CustomCharts/HighchartBarChart.bs.js";
import * as HighchartPieChart from "./CustomCharts/HighchartPieChart.bs.js";
import * as JsxPPXReactSupport from "rescript/lib/es6/jsxPPXReactSupport.js";
import * as EulerAnalyticsLogUtils from "../entities/analytics/EulerAnalyticsLogUtils.bs.js";
import * as HighchartTimeSeriesChart from "./CustomCharts/HighchartTimeSeriesChart.bs.js";
import * as HighchartHorizontalBarChart from "./CustomCharts/HighchartHorizontalBarChart.bs.js";

function getTimeSeriesChart(chartEntity) {
  var metricsArr = chartEntity.metrics.map(function (item) {
    return item.metric_name_db;
  });
  return JSON.stringify([
    AnalyticsUtils.getFilterRequestBody(
      Caml_option.some(chartEntity.granularityOpts),
      Caml_option.some(chartEntity.groupByNames),
      Caml_option.some(chartEntity.filters),
      Caml_option.some(metricsArr),
      chartEntity.delta,
      Caml_option.some(chartEntity.prefix),
      undefined,
      chartEntity.start_time,
      chartEntity.end_time,
      Caml_option.some(chartEntity.cardinality),
      Caml_option.some(chartEntity.mode),
      Core__Option.getOr(chartEntity.customFilter, ""),
      chartEntity.source,
      undefined,
    ),
  ]);
}

function getLegendBody(chartEntity) {
  var metricsArr = chartEntity.metrics.map(function (item) {
    return item.metric_name_db;
  });
  return JSON.stringify([
    AnalyticsUtils.getFilterRequestBody(
      undefined,
      Caml_option.some(chartEntity.groupByNames),
      Caml_option.some(chartEntity.filters),
      Caml_option.some(metricsArr),
      chartEntity.delta,
      Caml_option.some(chartEntity.prefix),
      undefined,
      chartEntity.start_time,
      chartEntity.end_time,
      Caml_option.some(chartEntity.cardinality),
      Caml_option.some(chartEntity.mode),
      Core__Option.getOr(chartEntity.customFilter, ""),
      chartEntity.source,
      undefined,
    ),
  ]);
}

function chartMapper(str) {
  switch (str) {
    case /* Line */ 0:
      return "Line chart";
    case /* Bar */ 1:
      return "Bar Chart";
    case /* SemiDonut */ 2:
      return "SemiDonut Chart";
    case /* HorizontalBar */ 3:
      return "Horizontal Bar Chart";
    case /* Funnel */ 4:
      return "Funnel Chart";
  }
}

function chartReverseMappers(str) {
  switch (str) {
    case "Bar Chart":
      return /* Bar */ 1;
    case "Funnel Chart":
      return /* Funnel */ 4;
    case "Horizontal Bar Chart":
      return /* HorizontalBar */ 3;
    case "Line Chart":
      return /* Line */ 0;
    case "SemiDonut Chart":
      return /* SemiDonut */ 2;
    default:
      return /* Line */ 0;
  }
}

function makeEntity(
  uri,
  chartConfig,
  filterKeysOpt,
  dateFilterKeys,
  currentMetrics,
  cardinality,
  granularityOpt,
  chartTypesOpt,
  uriConfig,
  moduleName,
  sourceOpt,
  customFilterKey,
  getGranularity,
  enableLoadersOpt,
  chartDescription,
  sortingColumnLegend,
  jsonTransformer,
  param,
) {
  var filterKeys = filterKeysOpt !== undefined ? filterKeysOpt : [];
  var granularity =
    granularityOpt !== undefined ? granularityOpt : [/* G_ONEDAY */ 6];
  var chartTypes = chartTypesOpt !== undefined ? chartTypesOpt : [/* Line */ 0];
  var source = sourceOpt !== undefined ? sourceOpt : "BATCH";
  var enableLoaders = enableLoadersOpt !== undefined ? enableLoadersOpt : true;
  var granularity$1 =
    granularity.length === 0 ? [/* G_ONEDAY */ 6] : granularity;
  var chartTypes$1 = chartTypes.length === 0 ? [/* Line */ 0] : chartTypes;
  return {
    uri: uri,
    chartConfig: chartConfig,
    allFilterDimension: filterKeys,
    dateFilterKeys: dateFilterKeys,
    currentMetrics: currentMetrics,
    cardinality: cardinality,
    granularity: granularity$1,
    chartTypes: chartTypes$1,
    uriConfig: uriConfig,
    moduleName: moduleName,
    source: source,
    customFilterKey: customFilterKey,
    getGranularity: getGranularity,
    enableLoaders: enableLoaders,
    chartDescription: chartDescription,
    sortingColumnLegend: sortingColumnLegend,
    jsonTransformer: jsonTransformer,
  };
}

function useChartFetch(setStatusDict) {
  var fetchApi = AuthHooks.useApiFetcher(undefined);
  var addLogsAroundFetch =
    EulerAnalyticsLogUtils.useAddLogsAroundFetch(undefined);
  return function (updatedChartBody, setState) {
    Core__Promise.$$catch(
      Promise.all(
        updatedChartBody.map(function (item) {
          return Core__Promise.$$catch(
            Curry._3(
              addLogsAroundFetch,
              setStatusDict,
              "Chart Data Api",
              Curry._8(
                fetchApi,
                item.url,
                item.body,
                undefined,
                Caml_option.some(Object.fromEntries([["QueryType", "Chart"]])),
                /* Post */ 2,
                undefined,
                undefined,
                undefined,
              ),
            ).then(function (json) {
              var dataRawTimeSeries = LogicUtils.getArrayFromJson(
                LogicUtils.getJsonObjectFromDict(
                  LogicUtils.getDictFromJsonObject(json),
                  "queryData",
                ),
                [],
              );
              var legendBody = item.legendBody;
              if (legendBody !== undefined) {
                return Core__Promise.$$catch(
                  Curry._3(
                    addLogsAroundFetch,
                    setStatusDict,
                    "Chart Data Api",
                    Curry._8(
                      fetchApi,
                      item.url,
                      legendBody,
                      undefined,
                      Caml_option.some(
                        Object.fromEntries([["QueryType", "Chart"]]),
                      ),
                      /* Post */ 2,
                      undefined,
                      undefined,
                      undefined,
                    ),
                  ).then(function (legendJson) {
                    var dataRawLegend = LogicUtils.getArrayFromJson(
                      LogicUtils.getJsonObjectFromDict(
                        LogicUtils.getDictFromJsonObject(legendJson),
                        "queryData",
                      ),
                      [],
                    );
                    return Promise.resolve({
                      metricsUrl: item.url,
                      rawData: dataRawTimeSeries,
                      legendData: dataRawLegend,
                    });
                  }),
                  function (_err) {
                    return Promise.resolve(undefined);
                  },
                );
              } else {
                return Promise.resolve({
                  metricsUrl: item.url,
                  rawData: dataRawTimeSeries,
                  legendData: [],
                });
              }
            }),
            function (_err) {
              return Promise.resolve(undefined);
            },
          );
        }),
      ).then(function (dataArr) {
        Curry._1(
          setState,
          Belt_Array.keepMap(dataArr, function (item) {
            return item;
          }),
        );
      }),
      function (_err) {
        return Promise.resolve(undefined);
      },
    );
  };
}

var cardinalityArr = ["TOP_5", "TOP_10"];

var chartTypeArr = [
  "Line chart",
  "Bar Chart",
  "SemiDonut Chart",
  "Horizontal Bar Chart",
  "Funnel Chart",
];

function DynamicChart(props) {
  var legendType = props.legendType;
  var showMarkers = props.showMarkers;
  var showTableLegend = props.showTableLegend;
  var enableBottomChart = props.enableBottomChart;
  var tabTitleMapper = props.tabTitleMapper;
  var updateUrl = props.updateUrl;
  var chartId = props.chartId;
  var modeKey = props.modeKey;
  var selectedTab = props.selectedTab;
  var entity = props.entity;
  var chartId$1 = chartId !== undefined ? chartId : "";
  var enableBottomChart$1 =
    enableBottomChart !== undefined ? enableBottomChart : true;
  var showTableLegend$1 =
    showTableLegend !== undefined ? showTableLegend : true;
  var showMarkers$1 = showMarkers !== undefined ? showMarkers : false;
  var legendType$1 = legendType !== undefined ? legendType : /* Table */ 0;
  var isoStringToCustomTimeZone =
    TimeZoneHook.useIsoStringToCustomTimeZone(undefined);
  var updateChartCompFilters =
    updateUrl !== undefined ? updateUrl : function (param) {};
  var currentTheme = ThemeProvider.useTheme(undefined);
  var match = React.useContext(FilterContext.filterContext);
  var match$1 = React.useState(function () {
    return false;
  });
  var setSwitchToMobileView = match$1[1];
  var match$2 = React.useState(function () {
    return selectedTab;
  });
  var setSelectedTabState = match$2[1];
  var selectedTabState = match$2[0];
  var customFilterKey = entity.customFilterKey;
  var customFilterKey$1 = customFilterKey !== undefined ? customFilterKey : "";
  var getGranularity = entity.getGranularity;
  var getGranularity$1 =
    getGranularity !== undefined
      ? getGranularity
      : LineChartUtils.getGranularity;
  var getAllFilter = Object.fromEntries(
    Object.entries(match.filterValue).map(function (item) {
      return [item[0], UrlFetchUtils.getFilterValue(item[1])];
    }),
  );
  var getChartCompFilters = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var value = item[1];
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          var fitlerName = Core__Option.getOr(keyArr[1], "");
          if (LogicUtils.isEmptyString(chartId$1)) {
            return [prefix, value];
          } else if (
            prefix === chartId$1 &&
            LogicUtils.isNonEmptyString(fitlerName)
          ) {
            return [fitlerName, value];
          } else {
            return;
          }
        }),
      );
    },
    [getAllFilter],
  );
  var getTopLevelFilter = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          if (prefix === chartId$1 && LogicUtils.isNonEmptyString(prefix)) {
            return;
          } else {
            return [prefix, item[1]];
          }
        }),
      );
    },
    [getAllFilter],
  );
  var mode =
    modeKey !== undefined
      ? LogicUtils.getString(getTopLevelFilter, modeKey, "")
      : "ORDER";
  var source = entity.source;
  var uriConfig = entity.uriConfig;
  var currentMetrics = entity.currentMetrics;
  var dateFilterKeys = entity.dateFilterKeys;
  var allFilterDimension = entity.allFilterDimension;
  var enableLoaders = Core__Option.getOr(entity.enableLoaders, true);
  var entityAllMetrics = Core__Array.reduce(
    uriConfig,
    [],
    function (acc, item) {
      return acc.concat(item.metrics);
    },
  );
  var currentBottomMetrix = currentMetrics[1];
  var currentTopMatrix = currentMetrics[0];
  React.useEffect(function () {
    var cardinality = LogicUtils.getString(
      getChartCompFilters,
      "cardinality",
      "TOP_5",
    );
    var chartType = LogicUtils.getString(
      getChartCompFilters,
      "chartType",
      chartMapper(Core__Option.getOr(entity.chartTypes[0], /* Line */ 0)),
    );
    var chartTopMetric = LogicUtils.getString(
      getChartCompFilters,
      "chartTopMetric",
      currentTopMatrix,
    );
    var chartBottomMetric = LogicUtils.getString(
      getChartCompFilters,
      "chartBottomMetric",
      currentBottomMetrix,
    );
    var dict = {};
    var chartMatrixArr = entityAllMetrics.map(function (item) {
      return item.metric_label;
    });
    if (cardinalityArr.includes(cardinality)) {
      dict["cardinality"] = cardinality;
    } else if (cardinalityArr.includes("TOP_5")) {
      dict["cardinality"] = "TOP_5";
    } else {
      dict["cardinality"] = Core__Option.getOr(cardinalityArr[0], "");
    }
    if (chartTypeArr.includes(chartType)) {
      dict["chartType"] = chartType;
    } else {
      dict["chartType"] = "Line chart";
    }
    if (chartMatrixArr.includes(chartTopMetric)) {
      dict["chartTopMetric"] = chartTopMetric;
    } else if (chartMatrixArr.includes(currentTopMatrix)) {
      dict["chartTopMetric"] = currentTopMatrix;
    } else {
      dict["chartTopMetric"] = Core__Option.getOr(chartMatrixArr[0], "");
    }
    if (chartMatrixArr.includes(chartBottomMetric)) {
      dict["chartBottomMetric"] = chartBottomMetric;
    } else if (chartMatrixArr.includes(currentBottomMetrix)) {
      dict["chartBottomMetric"] = currentBottomMetrix;
    } else {
      dict["chartBottomMetric"] = Core__Option.getOr(chartMatrixArr[0], "");
    }
    Curry._1(updateChartCompFilters, dict);
  }, []);
  var chartDimensionView;
  if (selectedTabState !== undefined) {
    var match$3 = selectedTabState.length;
    chartDimensionView =
      match$3 > 3 || match$3 < 1 ? /* No_Dims */ 3 : (match$3 - 1) | 0;
  } else {
    chartDimensionView = /* No_Dims */ 3;
  }
  var cardinalityFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "cardinality",
    "TOP_5",
  );
  var chartTypeFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "chartType",
    "Line chart",
  );
  var chartTopMetricFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "chartTopMetric",
    currentTopMatrix,
  );
  var chartBottomMetricFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "chartBottomMetric",
    currentBottomMetrix,
  );
  var match$4 = React.useState(function () {});
  var setGranularity = match$4[1];
  var granularity = match$4[0];
  var match$5 = React.useState(function () {});
  var setRawChartData = match$5[1];
  var rawChartData = match$5[0];
  var match$6 = React.useState(function () {
    return /* Shimmer */ 1;
  });
  var setShimmerType = match$6[1];
  var shimmerType = match$6[0];
  var match$7 = React.useState(function () {
    return "";
  });
  var setGroupKey = match$7[1];
  var groupKey = match$7[0];
  React.useEffect(
    function () {
      if (rawChartData !== undefined) {
        Curry._1(setShimmerType, function (param) {
          return /* SideLoader */ 0;
        });
      }
    },
    [rawChartData],
  );
  var endTimeFilterKey = dateFilterKeys[1];
  var startTimeFilterKey = dateFilterKeys[0];
  var defaultFilters =
    modeKey !== undefined
      ? [startTimeFilterKey, endTimeFilterKey, modeKey]
      : [startTimeFilterKey, endTimeFilterKey];
  var allFilterKeys = defaultFilters.concat(allFilterDimension);
  var match$8 = React.useMemo(
    function () {
      var filterSearchParam = Belt_Array.keepMap(
        Object.entries(getTopLevelFilter),
        function (entry) {
          var key = entry[0];
          if (!allFilterKeys.includes(key)) {
            return;
          }
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str === "number") {
            return;
          }
          switch (str.TAG | 0) {
            case /* String */ 1:
              return "" + key + "=" + str._0 + "";
            case /* Number */ 2:
              return "" + key + "=" + String(str._0) + "";
            case /* Array */ 4:
              return "" + key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
      return [
        filterSearchParam,
        LogicUtils.getString(getTopLevelFilter, customFilterKey$1, ""),
      ];
    },
    [getTopLevelFilter],
  );
  var endTimeFilterKey$1 = dateFilterKeys[1];
  var startTimeFilterKey$1 = dateFilterKeys[0];
  var customFilter = match$8[1];
  var topFiltersToSearchParam = match$8[0];
  var match$9 = React.useState(function () {
    return true;
  });
  var setIsExpandedUpper = match$9[1];
  var isExpandedUpper = match$9[0];
  var match$10 = React.useState(function () {
    return true;
  });
  var setIsExpandedLower = match$10[1];
  var isExpandedLower = match$10[0];
  var match$11 = React.useState(function () {
    return true;
  });
  var setChartLoading = match$11[1];
  var chartLoading = match$11[0];
  var match$12 = React.useState(function () {
    return false;
  });
  var setChartToggleKey = match$12[1];
  var chartToggleKey = match$12[0];
  var toggleKey = React.useMemo(
    function () {
      if (chartToggleKey) {
        return "0";
      } else {
        return "1";
      }
    },
    [chartToggleKey],
  );
  var isMobileView = MatchMedia.useMobileChecker(undefined);
  React.useEffect(
    function () {
      Curry._1(setSwitchToMobileView, function (prev) {
        if (prev) {
          return true;
        } else {
          return isMobileView;
        }
      });
    },
    [isMobileView],
  );
  var match$13 = React.useState(function () {
    return {};
  });
  var fetchChartData = useChartFetch(match$13[1]);
  var startTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(getTopLevelFilter, startTimeFilterKey$1, "");
    },
    [topFiltersToSearchParam],
  );
  var endTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(getTopLevelFilter, endTimeFilterKey$1, "");
    },
    [topFiltersToSearchParam],
  );
  var topFiltersToSearchParam$1 = React.useMemo(
    function () {
      return Belt_Array.keepMap(
        Object.entries(getTopLevelFilter),
        function (entry) {
          var key = entry[0];
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str === "number") {
            return;
          }
          switch (str.TAG | 0) {
            case /* String */ 1:
              return "" + key + "=" + str._0 + "";
            case /* Number */ 2:
              return "" + key + "=" + String(str._0) + "";
            case /* Array */ 4:
              return "" + key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
    },
    [topFiltersToSearchParam],
  );
  var current_granularity =
    LogicUtils.isNonEmptyString(startTimeFromUrl) &&
    LogicUtils.isNonEmptyString(endTimeFromUrl)
      ? Curry._2(getGranularity$1, startTimeFromUrl, endTimeFromUrl)
      : [];
  React.useEffect(
    function () {
      Curry._1(setGranularity, function (prev) {
        if (current_granularity.includes(Core__Option.getOr(prev, ""))) {
          return prev;
        } else {
          return current_granularity[0];
        }
      });
    },
    [startTimeFromUrl, endTimeFromUrl],
  );
  var selectedTabStr = Core__Option.getOr(selectedTab, []).join("");
  var updatedChartConfigArr = React.useMemo(
    function () {
      return uriConfig.map(function (item) {
        var filterKeys = item.filterKeys.filter(function (item) {
          return allFilterDimension.includes(item);
        });
        var filterValue = Object.fromEntries(
          Belt_Array.keepMap(
            Object.entries(getTopLevelFilter),
            function (entries) {
              var key = entries[0];
              if (filterKeys.includes(key)) {
                return [key, entries[1]];
              }
            },
          ),
        );
        var activeTab = Core__Option.getOr(
          Core__Option.getOr(selectedTab, [])[0],
          "",
        );
        var granularity$1 =
          activeTab === "run_date"
            ? "G_ONEHOUR"
            : activeTab === "run_week" || activeTab === "run_month"
              ? "G_ONEDAY"
              : granularity;
        return {
          uri: item.uri,
          metrics: item.metrics,
          groupByNames: selectedTab,
          start_time: startTimeFromUrl,
          end_time: endTimeFromUrl,
          filters: Caml_option.some(filterValue),
          granularityOpts: granularity$1,
          delta: false,
          startDateTime: startTimeFromUrl,
          cardinality: cardinalityFromUrl,
          mode: mode,
          prefix: item.prefix,
          source: source,
          customFilter: customFilter,
        };
      });
    },
    [
      startTimeFromUrl,
      endTimeFromUrl,
      customFilter,
      topFiltersToSearchParam$1,
      cardinalityFromUrl,
      selectedTabStr,
      granularity,
    ],
  );
  var updatedChartBody = React.useMemo(
    function () {
      return Belt_Array.keepMap(uriConfig, function (item) {
        var chartconfig = updatedChartConfigArr.find(function (config) {
          return config.uri === item.uri;
        });
        if (chartconfig === undefined) {
          return;
        }
        var legendBody = item.legendBody;
        var legendBody$1 =
          legendBody !== undefined
            ? Curry._1(legendBody, chartconfig)
            : undefined;
        return {
          url: item.uri,
          body: Curry._1(item.timeSeriesBody, chartconfig),
          legendBody:
            Core__Option.getOr(chartconfig.groupByNames, []).length === 1
              ? legendBody$1
              : undefined,
          metrics: item.metrics,
          timeCol: item.timeCol,
        };
      });
    },
    [updatedChartConfigArr],
  );
  var match$14 = React.useMemo(
    function () {
      if (tabTitleMapper === undefined) {
        if (selectedTab !== undefined) {
          return [
            Core__Option.getOr(selectedTab[0], ""),
            Core__Option.getOr(selectedTab[0], ""),
          ];
        } else {
          return ["", ""];
        }
      }
      if (selectedTab === undefined) {
        return ["", ""];
      }
      var groupKey = Core__Option.getOr(selectedTab[0], "");
      return [
        groupKey,
        Core__Option.getOr(
          Caml_option.valFromOption(tabTitleMapper)[groupKey],
          groupKey,
        ),
      ];
    },
    [selectedTab],
  );
  var titleKey = match$14[1];
  var groupKeyFromTab = match$14[0];
  var setRawChartData$1 = function (data) {
    var chartData = data.map(function (mappedData) {
      var rawdata = mappedData.rawData.map(function (item) {
        var dict = Core__Option.getOr(Core__JSON.Decode.object(item), {});
        var jsonObj = dict["time_range"];
        if (jsonObj !== undefined) {
          var timeDict = LogicUtils.getDictFromJsonObject(
            Caml_option.valFromOption(jsonObj),
          );
          var startValue = timeDict["startTime"];
          if (startValue !== undefined) {
            var sTime = Core__Option.getOr(
              Core__JSON.Decode.string(Caml_option.valFromOption(startValue)),
              "",
            );
            if (LogicUtils.isNonEmptyString(sTime)) {
              var match = Curry._1(
                isoStringToCustomTimeZone,
                new Date(sTime).toISOString(),
              );
              dict["time_bucket"] =
                "" +
                match.year +
                "-" +
                match.month +
                "-" +
                match.date +
                " " +
                match.hour +
                ":" +
                match.minute +
                ":" +
                match.second +
                "";
            }
          }
        }
        Core__Option.getOr(selectedTab, []).forEach(function (tabName) {
          var metric = Core__Option.getOr(
            Core__JSON.Decode.string(Core__Option.getOr(dict[tabName], "")),
            "",
          );
          var label = LogicUtils.isEmptyString(metric) ? "other" : metric;
          dict[tabName] = label;
          Object.keys(dict).forEach(function (key) {
            if (key.includes("amount")) {
              var amount = Core__Option.getOr(
                Core__JSON.Decode.$$float(Core__Option.getOr(dict[key], 0.0)),
                0.0,
              );
              var amount$1 = (amount / 100.0).toFixed(2);
              dict[key] = Number(amount$1);
              return;
            }
            if (!(!key.includes("time") && key !== tabName)) {
              return;
            }
            var val = dict[key];
            if (val === undefined) {
              return;
            }
            var val2 = Core__JSON.Decode.$$float(
              Caml_option.valFromOption(val),
            );
            if (val2 !== undefined) {
              dict[key] = val2.toFixed(2);
              return;
            }
          });
        });
        return dict;
      });
      return {
        metricsUrl: mappedData.metricsUrl,
        rawData: rawdata,
        legendData: mappedData.legendData,
      };
    });
    Curry._1(setGroupKey, function (param) {
      return groupKeyFromTab;
    });
    Curry._1(setSelectedTabState, function (param) {
      return selectedTab;
    });
    Curry._1(setRawChartData, function (param) {
      return chartData;
    });
    Curry._1(setChartLoading, function (param) {
      return false;
    });
  };
  React.useEffect(
    function () {
      if (!chartLoading) {
        Curry._1(setChartToggleKey, function (prev) {
          return !prev;
        });
      }
    },
    [chartLoading],
  );
  React.useEffect(
    function () {
      var chartType = LogicUtils.getString(
        getChartCompFilters,
        "chartType",
        chartMapper(Core__Option.getOr(entity.chartTypes[0], /* Line */ 0)),
      );
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFilterKey$1) &&
        (Core__Option.isSome(granularity) || chartType !== "Line Chart") &&
        current_granularity.includes(Core__Option.getOr(granularity, ""))
      ) {
        Curry._1(setChartLoading, function (param) {
          return enableLoaders;
        });
        Curry._2(fetchChartData, updatedChartBody, setRawChartData$1);
      }
    },
    [updatedChartBody],
  );
  var inputMetricTop_onBlur = function (_ev) {};
  var inputMetricTop_onChange = function (ev) {
    Curry._1(
      updateChartCompFilters,
      Object.fromEntries([["chartTopMetric", ev]]),
    );
  };
  var inputMetricTop_onFocus = function (_ev) {};
  var inputMetricTop = {
    name: "inputMetricTop",
    onBlur: inputMetricTop_onBlur,
    onChange: inputMetricTop_onChange,
    onFocus: inputMetricTop_onFocus,
    value: chartTopMetricFromUrl,
    checked: true,
  };
  var inputMetricBottom_onBlur = function (_ev) {};
  var inputMetricBottom_onChange = function (ev) {
    Curry._1(
      updateChartCompFilters,
      Object.fromEntries([["chartBottomMetric", ev]]),
    );
  };
  var inputMetricBottom_onFocus = function (_ev) {};
  var inputMetricBottom = {
    name: "inputMetricBottom",
    onBlur: inputMetricBottom_onBlur,
    onChange: inputMetricBottom_onChange,
    onFocus: inputMetricBottom_onFocus,
    value: chartBottomMetricFromUrl,
    checked: true,
  };
  var dropDownButtonTextStyle = "font-medium text-jp-gray-900 dark:text-white";
  var customButtonStyle = "dark:bg-inherit";
  var metricsDropDown = React.useMemo(
    function () {
      return entityAllMetrics.map(function (item) {
        return {
          label: item.metric_label,
          value: item.metric_label,
        };
      });
    },
    [entityAllMetrics, isMobileView],
  );
  var metricPickerdisplayClass = [
    /* SemiDonut */ 2, /* HorizontalBar */ 3, /* Funnel */ 4,
  ].includes(chartReverseMappers(chartTypeFromUrl))
    ? "hidden"
    : "";
  if (Object.values(match$13[0]).includes(504)) {
    return React.createElement(AnalyticsUtils.NoDataFoundPage.make, {});
  }
  var tmp;
  if (enableBottomChart$1) {
    var selectedMetrics = entityAllMetrics.filter(function (item) {
      return item.metric_label === chartBottomMetricFromUrl;
    })[0];
    if (selectedMetrics !== undefined) {
      var metricsUri = uriConfig.find(function (uriMetrics) {
        return uriMetrics.metrics
          .map(function (item) {
            return item.metric_label;
          })
          .includes(selectedMetrics.metric_label);
      });
      var match$15;
      if (metricsUri !== undefined) {
        var dataVal = Core__Option.getOr(rawChartData, []).find(
          function (item) {
            return item.metricsUrl === metricsUri.uri;
          },
        );
        match$15 =
          dataVal !== undefined
            ? [dataVal.rawData, dataVal.legendData, metricsUri.timeCol]
            : [[], [], ""];
      } else {
        match$15 = [[], [], ""];
      }
      if (isMobileView) {
        tmp = null;
      } else {
        var timeCol = match$15[2];
        var data = match$15[0];
        var tmp$1;
        if (chartLoading && shimmerType === /* SideLoader */ 0) {
          tmp$1 = React.createElement(
            "div",
            {
              className: "animate-spin mb-5 flex-end",
            },
            React.createElement(Icon.make, {
              name: "spinner",
              size: 20,
            }),
          );
        } else {
          var text = isExpandedLower ? "Collapse" : "Expand";
          tmp$1 = React.createElement(
            "div",
            {
              className: "cursor-pointer",
              onClick: function (param) {
                Curry._1(setIsExpandedLower, function (cont) {
                  return !cont;
                });
              },
            },
            React.createElement(
              "div",
              {
                className: "flex flex-col justify-center -ml-8 -mb-5",
              },
              React.createElement(Icon.make, {
                name: isExpandedLower ? "collpase-alt" : "expand-alt",
                size: 15,
              }),
            ),
            React.createElement(AddDataAttributes.make, {
              attributes: [["data-text", text]],
              children: React.createElement("div", undefined, text),
            }),
          );
        }
        var tmp$2;
        if (chartLoading && shimmerType === /* Shimmer */ 1) {
          tmp$2 = React.createElement(Shimmer.make, {
            styleClass: "w-full h-96",
            shimmerType: /* Big */ 1,
          });
        } else if (isExpandedLower) {
          switch (chartDimensionView) {
            case /* OneDimension */ 0:
              tmp$2 = React.createElement(
                HighchartTimeSeriesChart.LineChart1D.make,
                {
                  class:
                    "flex rounded overflow-scroll bg-white border-t-0 border-jp-gray-500 dark:border-jp-gray-960 dark:bg-jp-gray-950",
                  rawChartData: data,
                  selectedMetrics: selectedMetrics,
                  chartPlace: "bottom_",
                  xAxis: timeCol,
                  groupKey: groupKey,
                  chartTitle: false,
                  chartTitleText: selectedMetrics.metric_label + "-2",
                  legendType: legendType$1,
                  chartKey: toggleKey,
                  legendData: match$15[1],
                  showMarkers: showMarkers$1,
                },
              );
              break;
            case /* TwoDimension */ 1:
              tmp$2 = React.createElement(
                HighchartTimeSeriesChart.LineChart2D.make,
                {
                  groupBy: selectedTabState,
                  rawChartData: data,
                  selectedMetrics: selectedMetrics,
                  xAxis: timeCol,
                  class:
                    "flex rounded overflow-scroll bg-white border-t-0 border-jp-gray-500 dark:border-jp-gray-960 dark:bg-jp-gray-950",
                  chartKey: toggleKey,
                },
              );
              break;
            case /* ThreeDimension */ 2:
              tmp$2 = React.createElement(
                HighchartTimeSeriesChart.LineChart3D.make,
                {
                  groupBy: selectedTabState,
                  rawChartData: data,
                  selectedMetrics: selectedMetrics,
                  xAxis: timeCol,
                  class:
                    "flex rounded overflow-scroll bg-white border-t-0 border-jp-gray-500 dark:border-jp-gray-960 dark:bg-jp-gray-950",
                  chartKey: toggleKey,
                },
              );
              break;
            case /* No_Dims */ 3:
              tmp$2 = null;
              break;
          }
        } else {
          tmp$2 = null;
        }
        tmp = React.createElement(AddDataAttributes.make, {
          attributes: [["data-chart-segment", "Chart-2"]],
          children: React.createElement(
            "div",
            {
              className:
                "mt-5 rounded bg-white border dark:border-jp-gray-960 dark:bg-jp-gray-950",
            },
            React.createElement(
              "div",
              {
                className:
                  "flex flex-row justify-between dark:border-jp-gray-960 dark:bg-jp-gray-950 text-gray-500 p-4 py-2 border-b rounded bg-white border-jp-gray-500",
              },
              React.createElement(
                "div",
                {
                  className: "flex flex-row w-3/4 justify-center",
                },
                React.createElement(
                  "div",
                  {
                    className: "gap-1",
                    style: {
                      flexBasis: "16%",
                    },
                  },
                  React.createElement("div", undefined),
                  React.createElement("div", undefined),
                ),
                React.createElement(
                  "div",
                  undefined,
                  React.createElement(SelectBox.make, {
                    input: inputMetricBottom,
                    buttonText: "Choose Metric",
                    options: metricsDropDown,
                    buttonType:
                      currentTheme === /* Light */ 0
                        ? /* Secondary */ 1
                        : /* Pagination */ 5,
                    customButtonStyle: "metricButton " + customButtonStyle + "",
                    textStyle: "text-fs-13 " + dropDownButtonTextStyle + "",
                    searchable: false,
                    showBorder: false,
                    fixedDropDownDirection: /* BottomRight */ 2,
                  }),
                ),
              ),
              React.createElement(
                "div",
                {
                  className: "w-1/4 flex items-center justify-end",
                },
                tmp$1,
              ),
            ),
            tmp$2,
          ),
        });
      }
    } else {
      tmp = null;
    }
  } else {
    tmp = null;
  }
  return React.createElement(
    "div",
    undefined,
    React.createElement(ReactFinalForm$1.Form, {
      onSubmit: function (param, param$1) {
        return Promise.resolve(null);
      },
      render: function (param) {
        var tmp;
        if (chartLoading && shimmerType === /* SideLoader */ 0) {
          tmp = React.createElement(
            "div",
            {
              className: "animate-spin mb-4 flex-end",
            },
            React.createElement(Icon.make, {
              name: "spinner",
              size: 20,
            }),
          );
        } else {
          var tmp$1;
          if (isMobileView) {
            tmp$1 = null;
          } else {
            var text = isExpandedUpper ? "Collapse" : "Expand";
            tmp$1 = React.createElement(AddDataAttributes.make, {
              attributes: [["data-text", text]],
              children: React.createElement("div", undefined, text),
            });
          }
          tmp = React.createElement(
            "div",
            {
              className: "cursor-pointer pt-2",
              onClick: function (param) {
                Curry._1(setChartLoading, function (param) {
                  return false;
                });
                Curry._1(setIsExpandedUpper, function (cont) {
                  return !cont;
                });
              },
            },
            React.createElement(
              "div",
              {
                className: isMobileView
                  ? ""
                  : "flex flex-col justify-center -ml-8 -mb-5",
              },
              React.createElement(Icon.make, {
                name: isExpandedUpper ? "collpase-alt" : "expand-alt",
                size: 15,
              }),
            ),
            tmp$1,
          );
        }
        var tmp$2;
        if (chartLoading && shimmerType === /* Shimmer */ 1) {
          tmp$2 = React.createElement(Shimmer.make, {
            styleClass: "w-full h-96 dark:bg-black bg-white",
            shimmerType: /* Big */ 1,
          });
        } else if (isExpandedUpper) {
          var selectedMetrics = entityAllMetrics.filter(function (item) {
            return item.metric_label === chartTopMetricFromUrl;
          })[0];
          if (selectedMetrics !== undefined) {
            var metricsUri = uriConfig.find(function (uriMetrics) {
              return uriMetrics.metrics
                .map(function (item) {
                  return item.metric_label;
                })
                .includes(selectedMetrics.metric_label);
            });
            var match;
            if (metricsUri !== undefined) {
              var dataVal = Core__Option.getOr(rawChartData, []).find(
                function (item) {
                  return item.metricsUrl === metricsUri.uri;
                },
              );
              match =
                dataVal !== undefined
                  ? [dataVal.rawData, dataVal.legendData, metricsUri.timeCol]
                  : [[], [], ""];
            } else {
              match = [[], [], ""];
            }
            var timeCol = match[2];
            var data = match[0];
            var match$1 = chartReverseMappers(chartTypeFromUrl);
            switch (match$1) {
              case /* Line */ 0:
                switch (chartDimensionView) {
                  case /* OneDimension */ 0:
                    tmp$2 = JsxPPXReactSupport.createElementWithKey(
                      toggleKey,
                      HighchartTimeSeriesChart.LineChart1D.make,
                      {
                        class: "flex overflow-scroll",
                        rawChartData: data,
                        selectedMetrics: selectedMetrics,
                        chartPlace: "top_",
                        xAxis: timeCol,
                        groupKey: groupKey,
                        chartTitle: false,
                        showTableLegend: showTableLegend$1,
                        legendType: legendType$1,
                        legendData: match[1],
                        showMarkers: showMarkers$1,
                      },
                    );
                    break;
                  case /* TwoDimension */ 1:
                    tmp$2 = JsxPPXReactSupport.createElementWithKey(
                      toggleKey,
                      HighchartTimeSeriesChart.LineChart2D.make,
                      {
                        groupBy: selectedTabState,
                        rawChartData: data,
                        selectedMetrics: selectedMetrics,
                        xAxis: timeCol,
                      },
                    );
                    break;
                  case /* ThreeDimension */ 2:
                    tmp$2 = React.createElement(
                      HighchartTimeSeriesChart.LineChart3D.make,
                      {
                        groupBy: selectedTabState,
                        rawChartData: data,
                        selectedMetrics: selectedMetrics,
                        xAxis: timeCol,
                        chartKey: toggleKey,
                      },
                    );
                    break;
                  case /* No_Dims */ 3:
                    tmp$2 = null;
                    break;
                }
                break;
              case /* Bar */ 1:
                tmp$2 = React.createElement(
                  "div",
                  {
                    className: "",
                  },
                  JsxPPXReactSupport.createElementWithKey(
                    toggleKey,
                    HighchartBarChart.HighBarChart1D.make,
                    {
                      rawData: data,
                      groupKey: groupKey,
                      selectedMetrics: selectedMetrics,
                    },
                  ),
                );
                break;
              case /* SemiDonut */ 2:
                tmp$2 = React.createElement(
                  "div",
                  {
                    className: "m-4",
                  },
                  JsxPPXReactSupport.createElementWithKey(
                    toggleKey,
                    HighchartPieChart.make,
                    {
                      rawData: data,
                      groupKey: groupKey,
                      titleKey: titleKey,
                      selectedMetrics: selectedMetrics,
                    },
                  ),
                );
                break;
              case /* HorizontalBar */ 3:
                tmp$2 = React.createElement(
                  "div",
                  {
                    className: "m-4",
                  },
                  JsxPPXReactSupport.createElementWithKey(
                    toggleKey,
                    HighchartHorizontalBarChart.make,
                    {
                      rawData: data,
                      groupKey: groupKey,
                      titleKey: titleKey,
                      selectedMetrics: selectedMetrics,
                    },
                  ),
                );
                break;
              case /* Funnel */ 4:
                tmp$2 = React.createElement(FunnelChart.make, {
                  data: data,
                  metrics: entityAllMetrics,
                  moduleName: entity.moduleName,
                  description: entity.chartDescription,
                });
                break;
            }
          } else {
            tmp$2 = null;
          }
        } else {
          tmp$2 = null;
        }
        return React.createElement(
          "form",
          {
            onSubmit: param.handleSubmit,
          },
          React.createElement(AddDataAttributes.make, {
            attributes: [["data-chart-segment", "Chart-1"]],
            children: React.createElement(
              "div",
              {
                className:
                  "border rounded bg-white border-jp-gray-500 dark:border-jp-gray-960 dark:bg-jp-gray-950 dynamicChart",
              },
              React.createElement(
                "div",
                {
                  className:
                    "flex flex-row border-b w-full border-jp-gray-500 dark:border-jp-gray-960 dark:bg-jp-gray-950 text-gray-500 px-4 py-2 " +
                    metricPickerdisplayClass +
                    "",
                },
                React.createElement(
                  "div",
                  {
                    className: "w-3/4 flex justify-between",
                  },
                  React.createElement(
                    "div",
                    undefined,
                    React.createElement(SelectBox.make, {
                      input: inputMetricTop,
                      buttonText: "Choose Metric",
                      options: metricsDropDown,
                      buttonType:
                        currentTheme === /* Light */ 0
                          ? /* Secondary */ 1
                          : /* Pagination */ 5,
                      customButtonStyle:
                        "metricButton " + customButtonStyle + "",
                      textStyle: "!text-fs-13 !" + dropDownButtonTextStyle + "",
                      searchable: false,
                      showBorder: false,
                      fixedDropDownDirection: /* BottomRight */ 2,
                    }),
                  ),
                  React.createElement("div", undefined),
                ),
                React.createElement(
                  "div",
                  {
                    className: "w-1/4 flex items-center justify-end",
                  },
                  tmp,
                ),
              ),
              tmp$2,
            ),
          }),
        );
      },
      subscription: ReactFinalForm.subscribeToValues,
    }),
    tmp,
  );
}

var make = DynamicChart;

export {
  getTimeSeriesChart,
  getLegendBody,
  chartMapper,
  chartReverseMappers,
  makeEntity,
  useChartFetch,
  cardinalityArr,
  chartTypeArr,
  make,
};
/* Icon Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Fetch from "bs-fetch/src/Fetch.bs.js";
import * as Modal from "../utils/Modal.bs.js";
import * as React from "react";
import * as Button from "./Button.bs.js";
import * as AuthHooks from "../hooks/AuthHooks.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as ToastState from "../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ShowDetails from "./ShowDetails.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as FormRenderer from "./form/FormRenderer.bs.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";

function AdvancedSearchModal$SearchActions(props) {
  return React.createElement(ShowDetails.EntityData.make, {
    dictData: props.dictData,
    detailsKeyList: props.detailsKeyList,
    entity: props.entity,
  });
}

var SearchActions = {
  make: AdvancedSearchModal$SearchActions,
};

function AdvancedSearchModal$AdvanceSearch(props) {
  var entity = props.entity;
  var detailsKey = entity.detailsKey;
  var requiredSearchFieldsList = entity.requiredSearchFieldsList;
  var optionalSearchFieldsList = entity.optionalSearchFieldsList;
  var setShowSearchDetailsModal = props.setShowSearchDetailsModal;
  var setSearchDataDict = props.setSearchDataDict;
  var setShowModal = props.setShowModal;
  var url = props.url;
  var fetchApi = AuthHooks.useApiFetcher(undefined);
  var initialValueJson = {};
  var showToast = ToastState.useShowToast(undefined);
  var onSubmit = function (values, param) {
    var dict = Core__JSON.Decode.object(values);
    var otherQueries =
      dict !== undefined
        ? Belt_Array.keepMap(
            Object.entries(Caml_option.valFromOption(dict)),
            function (entry) {
              var stringVal = LogicUtils.getStringFromJson(entry[1], "");
              if (LogicUtils.isNonEmptyString(stringVal)) {
                return "" + entry[0] + "=" + stringVal + "";
              }
            },
          ).join("&")
        : "";
    var finalUrl = LogicUtils.isNonEmptyString(otherQueries)
      ? "" + url + "?" + otherQueries + ""
      : url;
    return Core__Promise.$$catch(
      Curry._8(
        fetchApi,
        finalUrl,
        JSON.stringify(initialValueJson),
        undefined,
        undefined,
        /* Get */ 0,
        undefined,
        undefined,
        undefined,
      )
        .then(Fetch.$$Response.json)
        .then(function (json) {
          var jsonDict = Core__JSON.Classify.classify(json);
          var exit = 0;
          if (typeof jsonDict === "number" || jsonDict.TAG !== /* Object */ 3) {
            exit = 1;
          } else {
            var jsonDict$1 = jsonDict._0;
            var statusStr = LogicUtils.getString(
              jsonDict$1,
              "status",
              "FAILURE",
            );
            if (statusStr === "SUCCESS") {
              var payloadDict = Core__Option.flatMap(
                jsonDict$1[detailsKey],
                Core__JSON.Decode.object,
              );
              if (payloadDict !== undefined) {
                var dict = Caml_option.valFromOption(payloadDict);
                Curry._1(setShowModal, function (param) {
                  return false;
                });
                Curry._1(setSearchDataDict, function (param) {
                  return Caml_option.some(dict);
                });
                Curry._1(setShowSearchDetailsModal, function (param) {
                  return true;
                });
              } else {
                Curry._8(
                  showToast,
                  "Something went wrong. Please try again",
                  /* ToastError */ 0,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                );
              }
            } else {
              Curry._8(
                showToast,
                "Data Not Found",
                /* ToastWarning */ 1,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
              );
            }
          }
          if (exit === 1) {
            Curry._8(
              showToast,
              "Something went wrong. Please try again",
              /* ToastError */ 0,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
            );
          }
          return Promise.resolve(json);
        }),
      function (_err) {
        Curry._8(
          showToast,
          "Something went wrong. Please try again",
          /* ToastError */ 0,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
        return Promise.resolve(null);
      },
    );
  };
  var validateForm = function (values) {
    var dict = Core__JSON.Decode.object(values);
    var valuesDict =
      dict !== undefined
        ? Object.fromEntries(Object.entries(Caml_option.valFromOption(dict)))
        : {};
    var errors = {};
    requiredSearchFieldsList.forEach(function (key) {
      if (Core__Option.isNone(valuesDict[key])) {
        errors[key] = "Required";
        return;
      }
    });
    var isSubmitEnabled = optionalSearchFieldsList.some(function (key) {
      return Core__Option.isSome(valuesDict[key]);
    });
    if (!isSubmitEnabled) {
      errors[optionalSearchFieldsList.join(",")] =
        "Atleast One of Optional fields is Required";
    }
    return errors;
  };
  return React.createElement(FormRenderer.make, {
    fields: props.searchFields,
    initialValues: initialValueJson,
    validate: validateForm,
    onSubmit: onSubmit,
    formClass: "md:justify-between p-2",
  });
}

var AdvanceSearch = {
  make: AdvancedSearchModal$AdvanceSearch,
};

function AdvancedSearchModal(props) {
  var entity = props.entity;
  var match = React.useState(function () {
    return false;
  });
  var setShowModal = match[1];
  var match$1 = React.useState(function () {});
  var searchDataDict = match$1[0];
  var match$2 = React.useState(function () {
    return false;
  });
  var setShowSearchDetailsModal = match$2[1];
  return React.createElement(
    React.Fragment,
    undefined,
    React.createElement(Button.make, {
      text: "Search",
      buttonType: /* Primary */ 0,
      leftIcon: {
        TAG: /* FontAwesome */ 0,
        _0: "search",
      },
      onClick: function (param) {
        Curry._1(setShowModal, function (param) {
          return true;
        });
      },
    }),
    React.createElement(Modal.make, {
      showModal: match[0],
      setShowModal: setShowModal,
      children: React.createElement(AdvancedSearchModal$AdvanceSearch, {
        searchFields: props.searchFields,
        url: props.url,
        entity: entity,
        setShowModal: setShowModal,
        setSearchDataDict: match$1[1],
        setShowSearchDetailsModal: setShowSearchDetailsModal,
      }),
      modalHeading: "Search",
      modalClass: "w-full md:w-3/12 mx-auto",
    }),
    searchDataDict !== undefined
      ? React.createElement(Modal.make, {
          showModal: match$2[0],
          setShowModal: setShowSearchDetailsModal,
          children: React.createElement(AdvancedSearchModal$SearchActions, {
            detailsKeyList: entity.searchKeyList,
            dictData: Caml_option.valFromOption(searchDataDict),
            entity: entity,
          }),
          modalHeading: "Search Details",
          modalClass: "w-full md:w-10/12  mx-auto",
        })
      : null,
  );
}

var make = AdvancedSearchModal;

export { SearchActions, AdvanceSearch, make };
/* Modal Not a pure module */

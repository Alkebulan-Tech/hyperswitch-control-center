// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../Icon.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Table from "../Table.bs.js";
import * as React from "react";
import * as ToolTip from "../tooltip/ToolTip.bs.js";
import * as UIUtils from "../../utils/UIUtils.bs.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as EntityType from "../../entities/EntityType.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as MatchMedia from "../../context/MatchMedia.bs.js";
import Highcharts from "highcharts";
import * as Highcharts$1 from "highcharts";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as LoadedTable from "../LoadedTable.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as NumericUtils from "../../utils/NumericUtils.bs.js";
import * as DateTimeUtils from "../../utils/DateTimeUtils.bs.js";
import * as ThemeProvider from "../../context/ThemeProvider.bs.js";
import * as LineChartUtils from "./LineChartUtils.bs.js";
import * as DictionaryUtils from "../../utils/DictionaryUtils.bs.js";
import * as SidebarProvider from "../../screens/Sidebar/SidebarProvider.bs.js";
import * as HSAnalyticsUtils from "../../screens/Analytics/HSAnalyticsUtils.bs.js";
import * as AddDataAttributes from "../AddDataAttributes.bs.js";
import * as JsxPPXReactSupport from "rescript/lib/es6/jsxPPXReactSupport.js";
import HighchartsReactOfficial from "highcharts-react-official";

function HighchartTimeSeriesChart$TooltipString(props) {
  var showTableBelow = props.showTableBelow;
  var text = props.text;
  var isMobileView = MatchMedia.useMobileChecker(undefined);
  var $$class = showTableBelow ? "w-fit" : "w-20";
  if (text.length > 15 && !showTableBelow) {
    return React.createElement(ToolTip.make, {
      description: text,
      toolTipFor: Caml_option.some(
        React.createElement(
          "div",
          {
            className: "whitespace-pre text-ellipsis overflow-x-hidden w-15",
          },
          React.createElement(AddDataAttributes.make, {
            attributes: [["data-text", text]],
            children: React.createElement(
              "div",
              undefined,
              "" + text.slice(0, 12) + "...",
            ),
          }),
        ),
      ),
      tooltipWidthClass: isMobileView ? "w-fit" : "",
      toolTipPosition: isMobileView ? /* TopRight */ 4 : /* Top */ 0,
      contentAlign: /* Left */ 0,
    });
  } else {
    return React.createElement(
      "div",
      {
        className: "whitespace-pre text-ellipsis " + $$class + "",
      },
      React.createElement(AddDataAttributes.make, {
        attributes: [["data-text", text]],
        children: React.createElement("div", undefined, text),
      }),
    );
  }
}

var TooltipString = {
  make: HighchartTimeSeriesChart$TooltipString,
};

function HighchartTimeSeriesChart$LineChart1D(props) {
  var showMarkers = props.showMarkers;
  var showIndicator = props.showIndicator;
  var isPartners = props.isPartners;
  var showTableBelow = props.showTableBelow;
  var selectedRow = props.selectedRow;
  var chartdataMaxRows = props.chartdataMaxRows;
  var legendData = props.legendData;
  var chartKey = props.chartKey;
  var isMultiDimensional = props.isMultiDimensional;
  var legendType = props.legendType;
  var showTableLegend = props.showTableLegend;
  var chartType = props.chartType;
  var showLegend = props.showLegend;
  var chartTitleText = props.chartTitleText;
  var chartTitle = props.chartTitle;
  var groupKey = props.groupKey;
  var xAxis = props.xAxis;
  var commonColorsArr = props.commonColorsArr;
  var selectedMetrics = props.selectedMetrics;
  var rawChartData = props.rawChartData;
  var $$class = props.class;
  var $$class$1 = $$class !== undefined ? $$class : "";
  var commonColorsArr$1 = commonColorsArr !== undefined ? commonColorsArr : [];
  var chartTitle$1 = chartTitle !== undefined ? chartTitle : false;
  var chartTitleText$1 = chartTitleText !== undefined ? chartTitleText : "";
  var showLegend$1 = showLegend !== undefined ? showLegend : false;
  var chartType$1 = chartType !== undefined ? chartType : "area";
  var showTableLegend$1 =
    showTableLegend !== undefined ? showTableLegend : true;
  var legendType$1 = legendType !== undefined ? legendType : /* Table */ 0;
  var isMultiDimensional$1 =
    isMultiDimensional !== undefined ? isMultiDimensional : false;
  var chartKey$1 = chartKey !== undefined ? chartKey : "0";
  var legendData$1 = legendData !== undefined ? legendData : [];
  var chartdataMaxRows$1 =
    chartdataMaxRows !== undefined ? chartdataMaxRows : -1;
  var selectedRow$1 =
    selectedRow !== undefined
      ? Caml_option.valFromOption(selectedRow)
      : undefined;
  var showTableBelow$1 = showTableBelow !== undefined ? showTableBelow : false;
  var isPartners$1 = isPartners !== undefined ? isPartners : false;
  var showIndicator$1 = showIndicator !== undefined ? showIndicator : false;
  var showMarkers$1 = showMarkers !== undefined ? showMarkers : false;
  var match = React.useContext(ThemeProvider.themeContext);
  var theme = match[0];
  var match$1 = React.useState(function () {
    return [];
  });
  var setLegendState = match$1[1];
  var isMobileView = MatchMedia.useMobileChecker(undefined);
  var match$2 = React.useState(function () {
    return isMobileView;
  });
  var setHideLegend = match$2[1];
  var hideLegend = match$2[0];
  var legendOption = selectedMetrics.legendOption;
  var match$3 =
    legendOption !== undefined && legendData$1.length > 0
      ? legendOption
      : LineChartUtils.legendTypeBasedOnMetric(selectedMetrics.metric_type);
  var secondLegend = match$3[1];
  var fistLegend = match$3[0];
  var match$4 = React.useState(function () {
    return [];
  });
  var setClickedRowNamesOrig = match$4[1];
  var clickedRowNames = match$4[0];
  var match$5 = React.useState(function () {});
  var setHoverOnRows = match$5[1];
  var hoverOnRows = match$5[0];
  var chartHeight = isMobileView ? 250 : 400;
  var setClickedRowNames = React.useMemo(
    function () {
      return function (param) {
        return Curry._1(setClickedRowNamesOrig, function (prev) {
          if (prev.includes(param.groupByName)) {
            return prev.filter(function (item) {
              return item !== param.groupByName;
            });
          } else {
            return [param.groupByName];
          }
        });
      };
    },
    [setClickedRowNamesOrig],
  );
  var match$6 = React.useMemo(
    function () {
      var chartdata = Belt_Array.keepMap(
        LineChartUtils.timeSeriesDataMaker(
          rawChartData,
          groupKey,
          xAxis,
          selectedMetrics,
          commonColorsArr$1,
          undefined,
        ),
        function (item) {
          if (
            ["run_date", "run_month", "run_week"].includes(groupKey) &&
            item.name === "Others"
          ) {
            return;
          }
          var newrecord = Caml_obj.obj_dup(item);
          return (
            (newrecord.data = item.data.map(function (dataItem) {
              var xAxis = dataItem[0];
              var updatedXAxis;
              if ("run_date" === groupKey) {
                updatedXAxis = (
                  "0" +
                  DateTimeUtils.toUtc(new Date(xAxis)).getHours().toString() +
                  ":00"
                ).slice(-5);
              } else if ("run_month" === groupKey) {
                updatedXAxis = DateTimeUtils.toUtc(new Date(xAxis))
                  .getDate()
                  .toString();
              } else if ("run_week" === groupKey) {
                var ele =
                  DateTimeUtils.daysArr[
                    DateTimeUtils.toUtc(new Date(xAxis)).getDay() | 0
                  ];
                updatedXAxis =
                  ele !== undefined ? DateTimeUtils.dayMapper(ele) : "";
              } else {
                updatedXAxis = xAxis;
              }
              return [updatedXAxis, dataItem[1], dataItem[2]];
            })),
            newrecord
          );
        },
      );
      var selectedChartData =
        selectedRow$1 !== undefined
          ? chartdata.filter(function (item) {
              return selectedRow$1.name === item.name;
            })
          : clickedRowNames.length > 0
            ? chartdata.filter(function (item) {
                return clickedRowNames.includes(item.name);
              })
            : chartdata;
      var xAxisMapInfo = {};
      selectedChartData.forEach(function (item) {
        item.data.forEach(function (axes) {
          var x = axes[0];
          LineChartUtils.appendToDictValue(
            xAxisMapInfo,
            ["run_date", "run_month", "run_week"].includes(groupKey)
              ? Core__Option.getOr(Core__JSON.Decode.string(x), "")
              : JSON.stringify(x),
            [
              item.name,
              Core__Option.getOr(item.color, "#000000"),
              axes[1],
              axes[2],
            ],
          );
        });
      });
      var data =
        clickedRowNames.length === 0 && hoverOnRows !== undefined
          ? chartdata.map(function (item) {
              var color = item.color;
              var color$1 =
                color !== undefined
                  ? item.name !== hoverOnRows
                    ? "" + color + "20"
                    : color
                  : undefined;
              var color$2 = item.fillColor;
              var fillColor;
              if (color$2 !== undefined) {
                var tmp;
                if (item.name !== hoverOnRows) {
                  var match = color$2.stops;
                  var match$1 = match[1];
                  var match$2 = match[0];
                  var newrecord = Caml_obj.obj_dup(color$2);
                  newrecord.stops = [
                    [match$2[0], LineChartUtils.reduceOpacity(match$2[1])],
                    [match$1[0], LineChartUtils.reduceOpacity(match$1[1])],
                  ];
                  tmp = newrecord;
                } else {
                  tmp = color$2;
                }
                fillColor = tmp;
              } else {
                fillColor = undefined;
              }
              var newrecord$1 = Caml_obj.obj_dup(item);
              newrecord$1.fillColor = fillColor;
              newrecord$1.color = color$1;
              return newrecord$1;
            })
          : selectedChartData;
      var chartData = Belt_Array.keepMap(data, function (chartDataItem) {
        var fillColor = chartDataItem.fillColor;
        var color = chartDataItem.color;
        if (
          !clickedRowNames.includes(chartDataItem.name) &&
          clickedRowNames.length > 0
        ) {
          return;
        }
        var value_name = chartDataItem.name;
        var value_data = chartDataItem.data.map(function (item) {
          return [item[0], item[1]];
        });
        var value_legendIndex = chartDataItem.legendIndex;
        var value = {
          name: value_name,
          data: value_data,
          color: color,
          legendIndex: value_legendIndex,
        };
        var newrecord = Caml_obj.obj_dup(value);
        return (newrecord.fillColor = fillColor), newrecord;
      });
      return [chartData, xAxisMapInfo, chartdata];
    },
    [
      xAxis,
      selectedMetrics,
      rawChartData,
      groupKey,
      clickedRowNames,
      hoverOnRows,
      selectedRow$1,
    ],
  );
  var chartDataOrig = match$6[2];
  var xAxisMapInfo = match$6[1];
  var chartData = match$6[0];
  var chartData$1 =
    chartdataMaxRows$1 !== -1
      ? chartData.slice(0, chartdataMaxRows$1)
      : chartData;
  var legendData$2 = React.useMemo(
    function () {
      var data = Belt_Array.keepMap(
        LineChartUtils.getLegendDataForCurrentMetrix(
          selectedMetrics.metric_name_db,
          rawChartData,
          legendData$1,
          groupKey,
          xAxis,
          selectedMetrics.metric_type,
        ),
        function (item) {
          if (
            ["run_date", "run_month", "run_week"].includes(groupKey) &&
            item.groupByName === "Others"
          ) {
            return;
          } else {
            return item;
          }
        },
      );
      if (chartdataMaxRows$1 !== -1) {
        return data.slice(0, chartdataMaxRows$1);
      } else {
        return data;
      }
    },
    [selectedMetrics, rawChartData, groupKey, xAxis, legendData$1],
  );
  var getCell = function (transactionTable, colType) {
    var colorOrig = Core__Option.getOr(
      Belt_Array.keepMap(chartDataOrig, function (item) {
        var color = item.color;
        if (color !== undefined && transactionTable.groupByName === item.name) {
          return color;
        }
      })[0],
      "",
    );
    var color = Core__Option.getOr(
      Belt_Array.keepMap(chartData$1, function (item) {
        var color = item.color;
        if (color !== undefined && transactionTable.groupByName === item.name) {
          return color;
        }
      })[0],
      "" + colorOrig + "",
    );
    var match =
      clickedRowNames.length === 0 ||
      clickedRowNames.includes(transactionTable.groupByName)
        ? ["", "" + color + ""]
        : ["opacity-40", "" + color + "50"];
    var nonSelectedClass = match[0];
    switch (colType) {
      case /* GroupBY */ 0:
        return {
          TAG: /* CustomCell */ 10,
          _0: React.createElement(
            "div",
            {
              className: "flex items-stretch justify-start select-none",
            },
            React.createElement("span", {
              className: "flex h-3 w-3 rounded-full self-center mr-2",
              style: {
                backgroundColor: match[1],
              },
            }),
            React.createElement(
              "span",
              {
                className: "flex justify-self-start " + nonSelectedClass + "",
              },
              React.createElement(HighchartTimeSeriesChart$TooltipString, {
                text: transactionTable.groupByName,
                showTableBelow: showTableBelow$1,
              }),
            ),
          ),
          _1: transactionTable.groupByName,
        };
      case /* Overall */ 1:
        var value = HSAnalyticsUtils.setPrecision(
          transactionTable.overall,
          undefined,
          undefined,
        );
        var value$1 = LineChartUtils.formatStatsAccToMetrix(
          selectedMetrics.metric_type,
          value,
        );
        return {
          TAG: /* CustomCell */ 10,
          _0: React.createElement(AddDataAttributes.make, {
            attributes: [["data-numeric", value$1]],
            children: React.createElement(
              "div",
              {
                className: nonSelectedClass,
              },
              value$1,
            ),
          }),
          _1: value$1,
        };
      case /* Average */ 2:
        var value$2 = HSAnalyticsUtils.setPrecision(
          transactionTable.average,
          undefined,
          undefined,
        );
        var value$3 = LineChartUtils.formatStatsAccToMetrix(
          selectedMetrics.metric_type,
          value$2,
        );
        return {
          TAG: /* CustomCell */ 10,
          _0: React.createElement(AddDataAttributes.make, {
            attributes: [["data-numeric", value$3]],
            children: React.createElement(
              "div",
              {
                className: nonSelectedClass,
              },
              value$3,
            ),
          }),
          _1: value$3,
        };
      case /* Current */ 3:
        var value$4 = HSAnalyticsUtils.setPrecision(
          transactionTable.current,
          undefined,
          undefined,
        );
        var value$5 = LineChartUtils.formatStatsAccToMetrix(
          selectedMetrics.metric_type,
          value$4,
        );
        return {
          TAG: /* CustomCell */ 10,
          _0: React.createElement(AddDataAttributes.make, {
            attributes: [["data-numeric", value$5]],
            children: React.createElement(
              "div",
              {
                className: nonSelectedClass,
              },
              value$5,
            ),
          }),
          _1: value$5,
        };
      case /* Emoji */ 4:
        return {
          TAG: /* CustomCell */ 10,
          _0:
            !transactionTable.groupByName.includes("Mid") &&
            isPartners$1 &&
            showIndicator$1
              ? React.createElement(
                  "div",
                  {
                    className: "flex items-stretch justify-start",
                  },
                  transactionTable.current < 20
                    ? React.createElement(
                        "div",
                        {
                          className: "flex items-stretch justify-start",
                        },
                        React.createElement(Icon.make, {
                          name: "sad-tear",
                          size: 18,
                          className: "text-red-500",
                        }),
                      )
                    : transactionTable.current < 40 ||
                        transactionTable.current < 50
                      ? React.createElement(Icon.make, {
                          name: "sad-tear",
                          size: 18,
                          className: "text-red-100",
                        })
                      : transactionTable.current < 60
                        ? React.createElement(Icon.make, {
                            name: "smile",
                            size: 18,
                            className: "text-green-200",
                          })
                        : transactionTable.current < 90
                          ? React.createElement(Icon.make, {
                              name: "smile",
                              size: 18,
                              className: "text-green-500",
                            })
                          : React.createElement(Icon.make, {
                              name: "smile",
                              size: 18,
                              className: "text-green-700",
                            }),
                )
              : null,
          _1: transactionTable.groupByName,
        };
      case /* NO_COL */ 5:
        return {
          TAG: /* CustomCell */ 10,
          _0: null,
          _1: transactionTable.groupByName,
        };
    }
  };
  var getHeading = function (colType) {
    if (colType !== 0) {
      return Table.makeHeaderInfo(
        LineChartUtils.chartLegendTypeToStr(colType).toLowerCase(),
        LineChartUtils.chartLegendTypeToStr(colType),
        /* NumericType */ 3,
        !isPartners$1,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    } else {
      return Table.makeHeaderInfo(
        "groupByName",
        LogicUtils.snakeToTitle(groupKey),
        /* LabelType */ 0,
        !isPartners$1,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    }
  };
  var legendTableEntity = EntityType.makeEntity(
    "",
    function (param) {
      return [];
    },
    [/* GroupBY */ 0, fistLegend, secondLegend],
    [/* GroupBY */ 0, fistLegend, secondLegend],
    getHeading,
    getCell,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
  );
  var match$7 = React.useContext(SidebarProvider.defaultContext);
  React.useEffect(
    function () {
      setTimeout(function (param) {
        window.dispatchEvent(new Event("resize"));
      }, 150);
    },
    [match$7.isSidebarExpanded],
  );
  var options = React.useMemo(
    function () {
      var chartTitleStyle = LineChartUtils.chartTitleStyle(theme);
      var thresholdVal = selectedMetrics.thresholdVal;
      var stepUpFromThreshold = selectedMetrics.step_up_threshold;
      var legend = legendType$1
        ? {
            enabled: !isMultiDimensional$1,
            itemStyle: LineChartUtils.legendItemStyle(
              theme,
              "IBM Plex Sans",
              "12px",
            ),
            itemHiddenStyle: function (param, param$1) {
              return LineChartUtils.legendHiddenStyle(theme, param, param$1);
            },
            itemHoverStyle: function (param, param$1) {
              return LineChartUtils.legendItemStyle(theme, param, param$1);
            },
          }
        : {
            enabled: isMobileView ? false : showLegend$1,
          };
      var defaultValue = {
        type: "datetime",
      };
      var labelsValue = {
        formatter: function () {
          var param = this;
          return LineChartUtils.formatLabels(
            selectedMetrics,
            Core__Option.getOr(param.value, 0.0),
          );
        },
        enabled: true,
        style: {
          fontFamily: "Inter",
          fontSize: "12px",
          fontStyle: "normal",
          fontWeight: 500,
          lineHeight: "20px",
          letterSpacing: "1px",
          color:
            theme === /* Light */ 0 ? "#4B5468" : "rgba(246, 248, 249, 0.25)",
        },
      };
      return {
        chart: {
          type: chartType$1,
          margin: undefined,
          zoomType: "x",
          backgroundColor: null,
          height: chartHeight,
          events: {
            render: function () {
              var $$this = this;
              var strokeColor = theme ? "#2e2f39" : "#e6e6e6";
              var ele = $$this.yAxis[0];
              if (ele !== undefined) {
                Highcharts$1.default.objectEach(ele.ticks, function (tick) {
                  if (tick.pos === thresholdVal) {
                    return tick.gridLine.attr({
                      "stroke-width": "0",
                    });
                  } else {
                    return tick.gridLine.attr({
                      stroke: strokeColor,
                    });
                  }
                });
                return;
              }
            },
          },
        },
        title: {
          text: chartTitle$1 ? chartTitleText$1 : "",
          style: chartTitleStyle,
        },
        series: chartData$1,
        plotOptions: {
          area: {
            pointStart: undefined,
            fillColor: undefined,
            fillOpacity: 0,
            states: {
              hover: {
                lineWidth: 1,
              },
            },
            lineWidth: 1.2,
            threshold: null,
          },
          line: {
            pointStart: undefined,
            fillColor: undefined,
            fillOpacity: 0,
            states: {
              hover: {
                lineWidth: 1,
              },
            },
            lineWidth: 1.2,
            threshold: null,
          },
          boxplot: {
            visible: false,
          },
          series: {
            marker: {
              enabled: showMarkers$1,
              radius: showMarkers$1 ? 5 : 1,
              symbol: "circle",
            },
            states: {
              hover: {
                enabled: true,
                halo: {
                  size: 10,
                },
              },
            },
            events: {
              legendItemClick: function (e) {
                var s = this;
                LineChartUtils.legendClickItem(s, e, setLegendState);
              },
              mouseOver: undefined,
            },
          },
        },
        xAxis: ["run_date", "run_month", "run_week"].includes(groupKey)
          ? {
              type: "category",
              tickWidth: 0,
            }
          : defaultValue,
        yAxis: {
          gridLineWidth: 1,
          tickWidth: 0,
          min: 0,
          gridLineColor: "#DDE3EE",
          gridLineDashStyle: "Dot",
          tickPositioner: function () {
            var param = this;
            if (thresholdVal === undefined) {
              return NumericUtils.pretty([0, param.dataMax], 5);
            }
            var upper_bound = param.dataMax;
            var upper_bound$1 =
              upper_bound <= thresholdVal
                ? thresholdVal + Core__Option.getOr(stepUpFromThreshold, 0)
                : upper_bound;
            var lower_bound =
              0 >= thresholdVal
                ? thresholdVal - Core__Option.getOr(stepUpFromThreshold, 0)
                : 0;
            var positions = NumericUtils.pretty(
              [lower_bound, upper_bound$1],
              5,
            );
            return positions
              .concat([thresholdVal])
              .toSorted(LogicUtils.numericArraySortComperator);
          },
          plotLines: [
            {
              label: {
                align: "right",
                style: {
                  color: "blue",
                  fontWeight: "bold",
                  background: "red",
                },
              },
              dashStyle: "Dash",
              value: thresholdVal,
              width: 1,
              color: "#ff0000",
            },
          ],
          visible: true,
          title: {
            text: "",
            style: chartTitleStyle,
          },
          labels: DictionaryUtils.deleteKey(
            LogicUtils.getDictFromJsonObject(labelsValue),
            "style",
          ),
        },
        credits: {
          enabled: false,
        },
        legend: legend,
        tooltip: {
          shared: false,
          enabled: true,
          useHTML: true,
          formatter: LineChartUtils.tooltipFormatter(
            selectedMetrics,
            xAxisMapInfo,
            groupKey,
          ),
          hideDelay: 0,
          outside: false,
          shape: "square",
          backgroundColor:
            theme === /* Light */ 0
              ? "rgba(25, 26, 26, 1)"
              : "rgba(247, 247, 250, 1)",
          borderColor:
            theme === /* Light */ 0
              ? "rgba(25, 26, 26, 1)"
              : "rgba(247, 247, 250, 1)",
          boxShadow: "",
          style: {
            color:
              theme === /* Light */ 0
                ? "rgba(246, 248, 249, 1)"
                : "rgba(25, 26, 26, 1)",
          },
        },
      };
    },
    [chartData$1, selectedMetrics, theme, isMobileView],
  );
  var match$8 = React.useState(function () {
    return 0;
  });
  var match$9 =
    showTableBelow$1 || isMobileView
      ? ["flex flex-col", "w-full", "w-full"]
      : ["flex flex-row", "w-1/5", "w-4/5"];
  if (chartData$1.length > 0) {
    return React.createElement(
      "div",
      {
        className: isMobileView
          ? "w-full"
          : isMultiDimensional$1
            ? "w-1/3"
            : "",
      },
      React.createElement(
        "div",
        {
          className: "" + match$9[0] + " " + $$class$1 + " px-4 pb-3",
        },
        React.createElement(AddDataAttributes.make, {
          attributes: [["data-chart", chartTitleText$1]],
          children: React.createElement(
            "div",
            {
              className: showTableLegend$1 ? match$9[2] : "w-full",
            },
            JsxPPXReactSupport.createElementWithKey(
              chartKey$1,
              HighchartsReactOfficial,
              {
                highcharts: Highcharts,
                options: options,
              },
            ),
          ),
        }),
        React.createElement(UIUtils.RenderIf.make, {
          condition: showTableLegend$1 && isMobileView,
          children: React.createElement(
            "div",
            {
              className:
                "flex flex-row items-center gap-2 w-fit self-end cursor-pointer mr-5 mb-2",
              onClick: function (param) {
                Curry._1(setHideLegend, function (prev) {
                  return !prev;
                });
              },
            },
            React.createElement(Icon.make, {
              name: hideLegend ? "collpase-alt" : "expand-alt",
              size: 12,
              className: "text-neutral-400",
            }),
          ),
        }),
        showTableLegend$1 && !hideLegend
          ? React.createElement(
              "div",
              {
                className: "" + match$9[1] + "  pl-5 pt-0 min-w-max",
              },
              React.createElement(LoadedTable.make, {
                visibleColumns: isPartners$1
                  ? [/* GroupBY */ 0, fistLegend, secondLegend, /* Emoji */ 4]
                  : [/* GroupBY */ 0, fistLegend, secondLegend],
                defaultSort: {
                  key: "index",
                  order: /* DEC */ 1,
                },
                title: "High Chart Time Series Chart",
                actualData: legendData$2.map(function (prim) {
                  return prim;
                }),
                totalResults: legendData$2.length,
                resultsPerPage: 15,
                offset: match$8[0],
                setOffset: match$8[1],
                entity: legendTableEntity,
                onEntityClick: Curry.__1(setClickedRowNames),
                onEntityDoubleClick: function (val) {
                  Curry._1(setClickedRowNamesOrig, function (param) {
                    return [];
                  });
                  if (clickedRowNames.length > 0) {
                    return Curry._1(setHoverOnRows, function (param) {});
                  }
                },
                currrentFetchCount: legendData$2.length,
                showPagination: false,
                hideTitle: true,
                onMouseEnter: function (val) {
                  if (clickedRowNames.length === 0) {
                    return Curry._1(setHoverOnRows, function (param) {
                      return val.groupByName;
                    });
                  }
                },
                onMouseLeave: function (val) {
                  if (clickedRowNames.length === 0) {
                    return Curry._1(setHoverOnRows, function (param) {});
                  }
                },
                isHighchartLegend: true,
                showTableOnMobileView: true,
              }),
            )
          : null,
      ),
    );
  } else {
    return null;
  }
}

var LineChart1D = {
  make: HighchartTimeSeriesChart$LineChart1D,
};

function HighchartTimeSeriesChart$LegendItem(props) {
  var setSelectedRow = props.setSelectedRow;
  var selectedRow = props.selectedRow;
  var opacity = function (name) {
    if (selectedRow !== undefined && selectedRow.name !== name) {
      return "opacity-40";
    } else {
      return "";
    }
  };
  return React.createElement(
    "div",
    {
      className: "flex flex-row m-5 gap-6 font-inter-style mobile:flex-wrap",
    },
    LineChartUtils.removeDuplicates(props.chartNames).map(
      function (legendItem) {
        var opacity$1 = opacity(legendItem.name);
        return React.createElement(AddDataAttributes.make, {
          attributes: [["data-chart-legend", legendItem.name]],
          children: React.createElement(
            "div",
            {
              className:
                "flex flex-row gap-2 justify-center items-center cursor-pointer " +
                opacity$1 +
                " select-none",
              onClick: function (param) {
                Curry._1(setSelectedRow, function (prev) {
                  if (prev !== undefined && prev.name === legendItem.name) {
                    return;
                  } else {
                    return legendItem;
                  }
                });
              },
              onDoubleClick: function (param) {
                if (Core__Option.isSome(selectedRow)) {
                  return Curry._1(setSelectedRow, function (param) {});
                }
              },
            },
            React.createElement("div", {
              className: "w-[0.9375rem] h-[0.9375rem] rounded",
              style: {
                background: legendItem.color,
              },
            }),
            React.createElement(
              "div",
              {
                className: "font-medium text-fs-14 text-[#3B424F]",
              },
              legendItem.name,
            ),
          ),
        });
      },
    ),
  );
}

var LegendItem = {
  make: HighchartTimeSeriesChart$LegendItem,
};

function HighchartTimeSeriesChart$RenderMultiDimensionalChart(props) {
  var config = props.config;
  var match = React.useState(function () {});
  var selectedRow = match[0];
  var chartNames = Core__Array.reduce(
    Object.entries(config.chartDictData),
    [],
    function (acc, param) {
      var chartdata = LineChartUtils.timeSeriesDataMaker(
        param[1],
        config.groupBy,
        config.xAxis,
        config.selectedMetrics,
        undefined,
        undefined,
      );
      chartdata.map(function (i) {
        acc.push({
          name: i.name,
          color: Core__Option.getOr(i.color, "#000000"),
          data: i.data.map(function (item) {
            return [item[0], item[1], item[2]];
          }),
          legendIndex: i.legendIndex,
        });
      });
      return acc;
    },
  );
  return React.createElement(
    "div",
    {
      className: "flex flex-col",
    },
    React.createElement(HighchartTimeSeriesChart$LegendItem, {
      chartNames: chartNames,
      selectedRow: selectedRow,
      setSelectedRow: match[1],
    }),
    React.createElement(
      "div",
      {
        className: "flex flex-wrap",
      },
      Object.entries(config.chartDictData).map(function (item, index) {
        return JsxPPXReactSupport.createElementWithKey(
          index.toString(),
          HighchartTimeSeriesChart$LineChart1D,
          {
            class: config.class,
            rawChartData: item[1],
            selectedMetrics: config.selectedMetrics,
            commonColorsArr: LineChartUtils.removeDuplicates(chartNames),
            xAxis: config.xAxis,
            groupKey: config.groupBy,
            chartTitle: true,
            chartTitleText: item[0],
            showLegend: false,
            chartType: config.chartType,
            showTableLegend: false,
            legendType: config.legendType,
            isMultiDimensional: true,
            chartKey: config.chartKey,
            selectedRow: Caml_option.some(selectedRow),
          },
        );
      }),
    ),
  );
}

var RenderMultiDimensionalChart = {
  make: HighchartTimeSeriesChart$RenderMultiDimensionalChart,
};

function HighchartTimeSeriesChart$LineChart2D(props) {
  var chartType = props.chartType;
  var chartKey = props.chartKey;
  var $$class = props.class;
  var legendType = props.legendType;
  var groupBy = props.groupBy;
  var legendType$1 = legendType !== undefined ? legendType : /* Points */ 1;
  var $$class$1 = $$class !== undefined ? $$class : "";
  var chartKey$1 = chartKey !== undefined ? chartKey : "0";
  var chartType$1 = chartType !== undefined ? chartType : "area";
  var match =
    groupBy !== undefined
      ? [Core__Option.getOr(groupBy[0], ""), Core__Option.getOr(groupBy[1], "")]
      : ["", ""];
  var groupBy2 = match[1];
  var chartDictData = {};
  props.rawChartData.forEach(function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    var groupBy = LogicUtils.getString(dict, groupBy2, "");
    var groupBy$1 = LogicUtils.isEmptyString(groupBy) ? "NA" : groupBy;
    LineChartUtils.appendToDictValue(chartDictData, groupBy$1, item);
  });
  var compProps_selectedMetrics = props.selectedMetrics;
  var compProps_groupBy = match[0];
  var compProps_xAxis = props.xAxis;
  var compProps = {
    chartDictData: chartDictData,
    class: $$class$1,
    selectedMetrics: compProps_selectedMetrics,
    groupBy: compProps_groupBy,
    xAxis: compProps_xAxis,
    chartKey: chartKey$1,
    legendType: legendType$1,
    chartType: chartType$1,
  };
  return React.createElement(
    HighchartTimeSeriesChart$RenderMultiDimensionalChart,
    {
      config: compProps,
    },
  );
}

var LineChart2D = {
  make: HighchartTimeSeriesChart$LineChart2D,
};

function HighchartTimeSeriesChart$LineChart3D(props) {
  var chartType = props.chartType;
  var chartKey = props.chartKey;
  var $$class = props.class;
  var legendType = props.legendType;
  var groupBy = props.groupBy;
  var legendType$1 = legendType !== undefined ? legendType : /* Points */ 1;
  var $$class$1 = $$class !== undefined ? $$class : "";
  var chartKey$1 = chartKey !== undefined ? chartKey : "0";
  var chartType$1 = chartType !== undefined ? chartType : "area";
  var match =
    groupBy !== undefined
      ? [
          Core__Option.getOr(groupBy[0], ""),
          Core__Option.getOr(groupBy[1], ""),
          Core__Option.getOr(groupBy[2], ""),
        ]
      : ["", "", ""];
  var groupby3 = match[2];
  var groupBy2 = match[1];
  var chartDictData = {};
  props.rawChartData.forEach(function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    var groupBy1 = LogicUtils.getString(dict, groupBy2, "");
    var groupBy1$1 = LogicUtils.isEmptyString(groupBy1) ? "NA" : groupBy1;
    var groupBy2$1 = LogicUtils.getString(dict, groupby3, "");
    var groupBy2$2 = LogicUtils.isEmptyString(groupBy2$1) ? "NA" : groupBy2$1;
    LineChartUtils.appendToDictValue(
      chartDictData,
      groupBy1$1 + " / " + groupBy2$2,
      item,
    );
  });
  var compProps_selectedMetrics = props.selectedMetrics;
  var compProps_groupBy = match[0];
  var compProps_xAxis = props.xAxis;
  var compProps = {
    chartDictData: chartDictData,
    class: $$class$1,
    selectedMetrics: compProps_selectedMetrics,
    groupBy: compProps_groupBy,
    xAxis: compProps_xAxis,
    chartKey: chartKey$1,
    legendType: legendType$1,
    chartType: chartType$1,
  };
  return React.createElement(
    HighchartTimeSeriesChart$RenderMultiDimensionalChart,
    {
      config: compProps,
    },
  );
}

var LineChart3D = {
  make: HighchartTimeSeriesChart$LineChart3D,
};

export {
  TooltipString,
  LineChart1D,
  LegendItem,
  RenderMultiDimensionalChart,
  LineChart2D,
  LineChart3D,
};
/* Icon Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as AuthHooks from "../hooks/AuthHooks.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";
import * as FilterContext from "./FilterContext.bs.js";
import * as LineChartUtils from "../components/CustomCharts/LineChartUtils.bs.js";
import * as DictionaryUtils from "../utils/DictionaryUtils.bs.js";
import * as AuthWrapperUtils from "../components/AuthWrapperUtils.bs.js";
import * as AnalyticsNewUtils from "../utils/AnalyticsNewUtils.bs.js";
import * as EulerAnalyticsLogUtils from "../entities/analytics/EulerAnalyticsLogUtils.bs.js";
import * as BetaEndPointConfigProvider from "./BetaEndPointConfigProvider.bs.js";

var singleStatComponentDefVal_singleStatLoader = {};

function singleStatComponentDefVal_singleStatIsVisible(param) {}

var singleStatComponentDefVal = {
  singleStatData: undefined,
  singleStatTimeSeries: undefined,
  singleStatDelta: undefined,
  singleStatLoader: singleStatComponentDefVal_singleStatLoader,
  singleStatIsVisible: singleStatComponentDefVal_singleStatIsVisible,
};

var singleStatContext = React.createContext(singleStatComponentDefVal);

var make = singleStatContext.Provider;

var Provider = {
  make: make,
};

function SingleStatContext(props) {
  var setIndividualSingleStatTime = props.setIndividualSingleStatTime;
  var setSingleStatTime = props.setSingleStatTime;
  var singleStatEntity = props.singleStatEntity;
  var setSingleStatTime$1 =
    setSingleStatTime !== undefined ? setSingleStatTime : function (param) {};
  var setIndividualSingleStatTime$1 =
    setIndividualSingleStatTime !== undefined
      ? setIndividualSingleStatTime
      : function (param) {};
  var metrixMapper = singleStatEntity.metrixMapper;
  var customFilterKey = singleStatEntity.customFilterKey;
  var moduleName = singleStatEntity.moduleName;
  var endTimeFilterKey = singleStatEntity.endTimeFilterKey;
  var startTimeFilterKey = singleStatEntity.startTimeFilterKey;
  var filterKeys = singleStatEntity.filterKeys;
  var modeKey = singleStatEntity.modeKey;
  var source = singleStatEntity.source;
  var dataFetcherObj = singleStatEntity.dataFetcherObj;
  var jsonTransformer = singleStatEntity.jsonTransformer;
  var jsonTransFormer =
    jsonTransformer !== undefined
      ? jsonTransformer
      : function (_val, arr) {
          return arr;
        };
  var match = React.useContext(FilterContext.filterContext);
  var filterValueJson = match.filterValueJson;
  var match$1 = React.useState(function () {
    return false;
  });
  var setSingleStatIsVisible = match$1[1];
  var isSingleStatVisible = match$1[0];
  var parentToken = AuthWrapperUtils.useTokenParent(/* Original */ 1);
  var addLogsAroundFetch =
    EulerAnalyticsLogUtils.useAddLogsAroundFetchNew(undefined);
  var betaEndPointConfig = React.useContext(
    BetaEndPointConfigProvider.betaEndPointConfig,
  );
  var func = AuthHooks.useApiFetcher(undefined);
  var fetchApi = function (param) {
    var func$1 = Curry._1(func, param);
    return function (param, param$1, param$2, param$3) {
      return Curry._5(
        func$1,
        param,
        param$1,
        param$2,
        param$3,
        betaEndPointConfig,
      );
    };
  };
  var getTopLevelSingleStatFilter = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(filterValueJson), function (item) {
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          if (prefix === moduleName && LogicUtils.isNonEmptyString(prefix)) {
            return;
          } else {
            return [prefix, item[1]];
          }
        }),
      );
    },
    [filterValueJson],
  );
  var match$2 = React.useMemo(
    function () {
      var modeValue = LogicUtils.getString(
        getTopLevelSingleStatFilter,
        modeKey,
        "",
      );
      var allFilterKeys = [
        startTimeFilterKey,
        endTimeFilterKey,
        Core__Option.getOr(modeValue, ""),
      ].concat(filterKeys);
      var filterSearchParam = Belt_Array.keepMap(
        Object.entries(getTopLevelSingleStatFilter),
        function (entry) {
          var key = entry[0];
          if (!allFilterKeys.includes(key)) {
            return;
          }
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str === "number") {
            return;
          }
          switch (str.TAG | 0) {
            case /* String */ 1:
              return "" + key + "=" + str._0 + "";
            case /* Number */ 2:
              return "" + key + "=" + String(str._0) + "";
            case /* Array */ 4:
              return "" + key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
      return [
        filterSearchParam,
        LogicUtils.getString(getTopLevelSingleStatFilter, customFilterKey, ""),
        modeValue,
      ];
    },
    [getTopLevelSingleStatFilter],
  );
  var modeValue = match$2[2];
  var customFilter = match$2[1];
  var topFiltersToSearchParam = match$2[0];
  var filterValueFromUrl = React.useMemo(
    function () {
      return Caml_option.some(
        LogicUtils.getJsonFromArrayOfJson(
          Belt_Array.keepMap(
            Object.entries(getTopLevelSingleStatFilter),
            function (entries) {
              var key = entries[0];
              if (filterKeys.includes(key)) {
                return [key, entries[1]];
              }
            },
          ),
        ),
      );
    },
    [topFiltersToSearchParam],
  );
  var startTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(
        getTopLevelSingleStatFilter,
        startTimeFilterKey,
        "",
      );
    },
    [topFiltersToSearchParam],
  );
  var endTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(
        getTopLevelSingleStatFilter,
        endTimeFilterKey,
        "",
      );
    },
    [topFiltersToSearchParam],
  );
  var initialValue = Object.fromEntries(
    dataFetcherObj.map(function (item) {
      var updatedMetrics = Curry._1(metrixMapper, item.metrics);
      return [updatedMetrics, /* Loading */ 0];
    }),
  );
  var initialValueLoader = Object.fromEntries(
    dataFetcherObj.map(function (item) {
      var updatedMetrics = Curry._1(metrixMapper, item.metrics);
      return [updatedMetrics, /* Shimmer */ 1];
    }),
  );
  var match$3 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatStateData = match$3[1];
  var singleStatStateData = match$3[0];
  var match$4 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatTimeSeries = match$4[1];
  var singleStatTimeSeries = match$4[0];
  var match$5 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatStateDataHistoric = match$5[1];
  var singleStatStateDataHistoric = match$5[0];
  var match$6 = React.useState(function () {
    return initialValueLoader;
  });
  var setSingleStatLoader = match$6[1];
  var singleStatLoader = match$6[0];
  var match$7 = React.useState(function () {
    return false;
  });
  var setIsSingleStatFetchedWithCurrentDependency = match$7[1];
  var singleStatFetchedWithCurrentDependency = match$7[0];
  React.useEffect(
    function () {
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFromUrl) &&
        Core__Option.isSome(parentToken)
      ) {
        Curry._1(setIsSingleStatFetchedWithCurrentDependency, function (param) {
          return false;
        });
      }
    },
    [
      endTimeFromUrl,
      startTimeFromUrl,
      filterValueFromUrl,
      parentToken,
      customFilter,
      modeValue,
    ],
  );
  React.useEffect(
    function () {
      if (!singleStatFetchedWithCurrentDependency && isSingleStatVisible) {
        Curry._1(setIsSingleStatFetchedWithCurrentDependency, function (param) {
          return true;
        });
        var granularity = LineChartUtils.getGranularityNew(
          startTimeFromUrl,
          endTimeFromUrl,
        );
        var filterConfigCurrent_modeValue = Core__Option.getOr(modeValue, "");
        var filterConfigCurrent_granularity = granularity[0];
        var filterConfigCurrent = {
          source: source,
          modeValue: filterConfigCurrent_modeValue,
          filterValues: filterValueFromUrl,
          startTime: startTimeFromUrl,
          endTime: endTimeFromUrl,
          customFilterValue: customFilter,
          granularity: filterConfigCurrent_granularity,
        };
        var match = AnalyticsNewUtils.calculateHistoricTime(
          startTimeFromUrl,
          endTimeFromUrl,
          undefined,
          undefined,
          undefined,
        );
        var newrecord = Caml_obj.obj_dup(filterConfigCurrent);
        newrecord.endTime = match[1];
        newrecord.startTime = match[0];
        Curry._1(setSingleStatTime$1, function (param) {
          return {
            apiStartTime: Date.now(),
            apiEndTime: 0,
          };
        });
        dataFetcherObj.map(function (urlConfig, index) {
          var url = urlConfig.url;
          var metrics = urlConfig.metrics;
          var updatedMetrics = Curry._1(metrixMapper, metrics);
          Curry._1(setIndividualSingleStatTime$1, function (prev) {
            var individualTime = Object.fromEntries(Object.entries(prev));
            individualTime[index.toString()] = Date.now();
            return individualTime;
          });
          Curry._1(setSingleStatStateData, function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = /* Loading */ 0;
            return prevDict;
          });
          Curry._1(setSingleStatTimeSeries, function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = /* Loading */ 0;
            return prevDict;
          });
          Curry._1(setSingleStatStateDataHistoric, function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = /* Loading */ 0;
            return prevDict;
          });
          var timeObj = Object.fromEntries([
            ["start", startTimeFromUrl],
            ["end", endTimeFromUrl],
          ]);
          var historicTimeObj = Object.fromEntries([
            ["start", newrecord.startTime],
            ["end", newrecord.endTime],
          ]);
          var granularity = filterConfigCurrent_granularity;
          var granularityConfig =
            granularity !== undefined ? granularity : [1, "hour"];
          var singleStatHistoricDataFetch = Core__Promise.$$catch(
            Curry._3(
              addLogsAroundFetch,
              undefined,
              "SingleStat histotic data for metrics " +
                Curry._1(metrixMapper, metrics) +
                "",
              Curry._2(
                fetchApi(
                  "" +
                    url +
                    "?api-type=singlestat&time=historic&metrics=" +
                    updatedMetrics +
                    "",
                )(
                  JSON.stringify(
                    AnalyticsNewUtils.apiBodyMaker(
                      historicTimeObj,
                      updatedMetrics,
                      undefined,
                      undefined,
                      undefined,
                      newrecord.filterValues,
                      newrecord.customFilterValue,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      urlConfig.domain,
                      undefined,
                      undefined,
                    ),
                  ),
                  undefined,
                  Caml_option.some(
                    Object.fromEntries([["QueryType", "SingleStatHistoric"]]),
                  ),
                  /* Post */ 2,
                ),
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              var jsonObj$1 = Curry._2(
                jsonTransFormer,
                updatedMetrics,
                jsonObj,
              );
              return Promise.resolve(
                (Curry._1(setSingleStatStateDataHistoric, function (prev) {
                  var prevDict = DictionaryUtils.copyOfDict(prev);
                  prevDict[updatedMetrics] = /* Loaded */ {
                    _0: Core__Option.getOr(jsonObj$1[0], {}),
                  };
                  return prevDict;
                }),
                /* Loaded */ {
                  _0: {},
                }),
              );
            }),
            function (_err) {
              Curry._1(setSingleStatStateDataHistoric, function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = /* LoadedError */ 1;
                return prevDict;
              });
              return Promise.resolve(/* LoadedError */ 1);
            },
          );
          var singleStatDataFetch = Core__Promise.$$catch(
            Curry._3(
              addLogsAroundFetch,
              undefined,
              "SingleStat data for metrics " +
                Curry._1(metrixMapper, metrics) +
                "",
              Curry._2(
                fetchApi(
                  "" +
                    url +
                    "?api-type=singlestat&metrics=" +
                    updatedMetrics +
                    "",
                )(
                  JSON.stringify(
                    AnalyticsNewUtils.apiBodyMaker(
                      timeObj,
                      updatedMetrics,
                      undefined,
                      undefined,
                      undefined,
                      filterValueFromUrl,
                      customFilter,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      urlConfig.domain,
                      undefined,
                      undefined,
                    ),
                  ),
                  undefined,
                  Caml_option.some(
                    Object.fromEntries([["QueryType", "SingleStat"]]),
                  ),
                  /* Post */ 2,
                ),
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              var jsonObj$1 = Curry._2(
                jsonTransFormer,
                updatedMetrics,
                jsonObj,
              );
              Curry._1(setSingleStatStateData, function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = /* Loaded */ {
                  _0: Core__Option.getOr(jsonObj$1[0], {}),
                };
                return prevDict;
              });
              return Promise.resolve(
                /* Loaded */ {
                  _0: {},
                },
              );
            }),
            function (_err) {
              Curry._1(setSingleStatStateData, function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = /* LoadedError */ 1;
                return prevDict;
              });
              return Promise.resolve(/* LoadedError */ 1);
            },
          );
          var singleStatDataFetchTimeSeries = Core__Promise.$$catch(
            Curry._3(
              addLogsAroundFetch,
              undefined,
              "SingleStat Time Series data for metrics " +
                Curry._1(metrixMapper, metrics) +
                "",
              Curry._2(
                fetchApi(
                  "" +
                    url +
                    "?api-type=singlestat-timeseries&metrics=" +
                    updatedMetrics +
                    "",
                )(
                  JSON.stringify(
                    AnalyticsNewUtils.apiBodyMaker(
                      timeObj,
                      updatedMetrics,
                      undefined,
                      granularityConfig,
                      undefined,
                      filterValueFromUrl,
                      customFilter,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      urlConfig.timeColumn,
                      urlConfig.domain,
                      undefined,
                      undefined,
                    ),
                  ),
                  undefined,
                  Caml_option.some(
                    Object.fromEntries([
                      ["QueryType", "SingleStat Time Series"],
                    ]),
                  ),
                  /* Post */ 2,
                ),
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj = LogicUtils.convertNewLineSaperatedDataToArrayOfJson(
                text,
              ).map(function (item) {
                return Object.fromEntries(
                  Object.entries(LogicUtils.getDictFromJsonObject(item)).map(
                    function (dictEn) {
                      var key = dictEn[0];
                      return [
                        key === "" + urlConfig.timeColumn + "_time"
                          ? "time"
                          : key,
                        dictEn[1],
                      ];
                    },
                  ),
                );
              });
              var jsonObj$1 = Curry._2(
                jsonTransFormer,
                updatedMetrics,
                jsonObj,
              );
              Curry._1(setSingleStatTimeSeries, function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = /* Loaded */ {
                  _0: jsonObj$1,
                };
                return prevDict;
              });
              return Promise.resolve(
                /* Loaded */ {
                  _0: {},
                },
              );
            }),
            function (_err) {
              Curry._1(setSingleStatTimeSeries, function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = /* LoadedError */ 1;
                return prevDict;
              });
              return Promise.resolve(/* LoadedError */ 1);
            },
          );
          Promise.all([
            singleStatDataFetchTimeSeries,
            singleStatHistoricDataFetch,
            singleStatDataFetch,
          ]).then(function (value) {
            var ssH = Core__Option.getOr(value[0], /* LoadedError */ 1);
            var ssT = Core__Option.getOr(value[1], /* LoadedError */ 1);
            var ssD = Core__Option.getOr(value[2], /* LoadedError */ 1);
            var isLoaded = function (val) {
              if (typeof val === "number") {
                return false;
              } else {
                return true;
              }
            };
            Curry._1(setSingleStatLoader, function (prev) {
              var prevDict = DictionaryUtils.copyOfDict(prev);
              if (isLoaded(ssH) && isLoaded(ssT) && isLoaded(ssD)) {
                prevDict[updatedMetrics] = /* SideLoader */ 0;
              }
              return prevDict;
            });
            Curry._1(setIndividualSingleStatTime$1, function (prev) {
              var individualTime = Object.fromEntries(Object.entries(prev));
              individualTime[index.toString()] =
                Date.now() -
                Core__Option.getOr(
                  individualTime[index.toString()],
                  Date.now(),
                );
              return individualTime;
            });
            if (index === ((dataFetcherObj.length - 1) | 0)) {
              return Curry._1(setSingleStatTime$1, function (prev) {
                return {
                  apiStartTime: prev.apiStartTime,
                  apiEndTime: Date.now(),
                };
              });
            }
          });
        });
      }
    },
    [singleStatFetchedWithCurrentDependency, isSingleStatVisible],
  );
  var value = React.useMemo(
    function () {
      return {
        singleStatData: Caml_option.some(singleStatStateData),
        singleStatTimeSeries: Caml_option.some(singleStatTimeSeries),
        singleStatDelta: Caml_option.some(singleStatStateDataHistoric),
        singleStatLoader: singleStatLoader,
        singleStatIsVisible: setSingleStatIsVisible,
      };
    },
    [
      singleStatStateData,
      singleStatTimeSeries,
      singleStatLoader,
      setSingleStatIsVisible,
    ],
  );
  return React.createElement(make, {
    value: value,
    children: props.children,
  });
}

var make$1 = SingleStatContext;

export {
  singleStatComponentDefVal,
  singleStatContext,
  Provider,
  make$1 as make,
};
/* singleStatContext Not a pure module */
